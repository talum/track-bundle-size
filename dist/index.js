require('./sourcemap-register.js');(()=>{var t={760:(t,r,n)=>{
/*! node-domexception. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */
if(!globalThis.DOMException){try{const{MessageChannel:t}=n(267),r=(new t).port1,a=new ArrayBuffer;r.postMessage(a,[a,a])}catch(t){t.constructor.name==="DOMException"&&(globalThis.DOMException=t.constructor)}}t.exports=globalThis.DOMException},452:function(t,r){
/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
(function(t,n){true?n(r):0})(this,(function(t){"use strict";function noop(){return undefined}function typeIsObject(t){return typeof t==="object"&&t!==null||typeof t==="function"}const r=noop;function setFunctionName(t,r){try{Object.defineProperty(t,"name",{value:r,configurable:true})}catch(t){}}const n=Promise;const a=Promise.prototype.then;const o=Promise.reject.bind(n);function newPromise(t){return new n(t)}function promiseResolvedWith(t){return newPromise((r=>r(t)))}function promiseRejectedWith(t){return o(t)}function PerformPromiseThen(t,r,n){return a.call(t,r,n)}function uponPromise(t,n,a){PerformPromiseThen(PerformPromiseThen(t,n,a),undefined,r)}function uponFulfillment(t,r){uponPromise(t,r)}function uponRejection(t,r){uponPromise(t,undefined,r)}function transformPromiseWith(t,r,n){return PerformPromiseThen(t,r,n)}function setPromiseIsHandledToTrue(t){PerformPromiseThen(t,undefined,r)}let _queueMicrotask=t=>{if(typeof queueMicrotask==="function"){_queueMicrotask=queueMicrotask}else{const t=promiseResolvedWith(undefined);_queueMicrotask=r=>PerformPromiseThen(t,r)}return _queueMicrotask(t)};function reflectCall(t,r,n){if(typeof t!=="function"){throw new TypeError("Argument is not a function")}return Function.prototype.apply.call(t,r,n)}function promiseCall(t,r,n){try{return promiseResolvedWith(reflectCall(t,r,n))}catch(t){return promiseRejectedWith(t)}}const l=16384;class SimpleQueue{constructor(){this._cursor=0;this._size=0;this._front={_elements:[],_next:undefined};this._back=this._front;this._cursor=0;this._size=0}get length(){return this._size}push(t){const r=this._back;let n=r;if(r._elements.length===l-1){n={_elements:[],_next:undefined}}r._elements.push(t);if(n!==r){this._back=n;r._next=n}++this._size}shift(){const t=this._front;let r=t;const n=this._cursor;let a=n+1;const o=t._elements;const i=o[n];if(a===l){r=t._next;a=0}--this._size;this._cursor=a;if(t!==r){this._front=r}o[n]=undefined;return i}forEach(t){let r=this._cursor;let n=this._front;let a=n._elements;while(r!==a.length||n._next!==undefined){if(r===a.length){n=n._next;a=n._elements;r=0;if(a.length===0){break}}t(a[r]);++r}}peek(){const t=this._front;const r=this._cursor;return t._elements[r]}}const i=Symbol("[[AbortSteps]]");const s=Symbol("[[ErrorSteps]]");const u=Symbol("[[CancelSteps]]");const d=Symbol("[[PullSteps]]");const c=Symbol("[[ReleaseSteps]]");function ReadableStreamReaderGenericInitialize(t,r){t._ownerReadableStream=r;r._reader=t;if(r._state==="readable"){defaultReaderClosedPromiseInitialize(t)}else if(r._state==="closed"){defaultReaderClosedPromiseInitializeAsResolved(t)}else{defaultReaderClosedPromiseInitializeAsRejected(t,r._storedError)}}function ReadableStreamReaderGenericCancel(t,r){const n=t._ownerReadableStream;return ReadableStreamCancel(n,r)}function ReadableStreamReaderGenericRelease(t){const r=t._ownerReadableStream;if(r._state==="readable"){defaultReaderClosedPromiseReject(t,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}else{defaultReaderClosedPromiseResetToRejected(t,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}r._readableStreamController[c]();r._reader=undefined;t._ownerReadableStream=undefined}function readerLockException(t){return new TypeError("Cannot "+t+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(t){t._closedPromise=newPromise(((r,n)=>{t._closedPromise_resolve=r;t._closedPromise_reject=n}))}function defaultReaderClosedPromiseInitializeAsRejected(t,r){defaultReaderClosedPromiseInitialize(t);defaultReaderClosedPromiseReject(t,r)}function defaultReaderClosedPromiseInitializeAsResolved(t){defaultReaderClosedPromiseInitialize(t);defaultReaderClosedPromiseResolve(t)}function defaultReaderClosedPromiseReject(t,r){if(t._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(t._closedPromise);t._closedPromise_reject(r);t._closedPromise_resolve=undefined;t._closedPromise_reject=undefined}function defaultReaderClosedPromiseResetToRejected(t,r){defaultReaderClosedPromiseInitializeAsRejected(t,r)}function defaultReaderClosedPromiseResolve(t){if(t._closedPromise_resolve===undefined){return}t._closedPromise_resolve(undefined);t._closedPromise_resolve=undefined;t._closedPromise_reject=undefined}const m=Number.isFinite||function(t){return typeof t==="number"&&isFinite(t)};const b=Math.trunc||function(t){return t<0?Math.ceil(t):Math.floor(t)};function isDictionary(t){return typeof t==="object"||typeof t==="function"}function assertDictionary(t,r){if(t!==undefined&&!isDictionary(t)){throw new TypeError(`${r} is not an object.`)}}function assertFunction(t,r){if(typeof t!=="function"){throw new TypeError(`${r} is not a function.`)}}function isObject(t){return typeof t==="object"&&t!==null||typeof t==="function"}function assertObject(t,r){if(!isObject(t)){throw new TypeError(`${r} is not an object.`)}}function assertRequiredArgument(t,r,n){if(t===undefined){throw new TypeError(`Parameter ${r} is required in '${n}'.`)}}function assertRequiredField(t,r,n){if(t===undefined){throw new TypeError(`${r} is required in '${n}'.`)}}function convertUnrestrictedDouble(t){return Number(t)}function censorNegativeZero(t){return t===0?0:t}function integerPart(t){return censorNegativeZero(b(t))}function convertUnsignedLongLongWithEnforceRange(t,r){const n=0;const a=Number.MAX_SAFE_INTEGER;let o=Number(t);o=censorNegativeZero(o);if(!m(o)){throw new TypeError(`${r} is not a finite number`)}o=integerPart(o);if(o<n||o>a){throw new TypeError(`${r} is outside the accepted range of ${n} to ${a}, inclusive`)}if(!m(o)||o===0){return 0}return o}function assertReadableStream(t,r){if(!IsReadableStream(t)){throw new TypeError(`${r} is not a ReadableStream.`)}}function AcquireReadableStreamDefaultReader(t){return new ReadableStreamDefaultReader(t)}function ReadableStreamAddReadRequest(t,r){t._reader._readRequests.push(r)}function ReadableStreamFulfillReadRequest(t,r,n){const a=t._reader;const o=a._readRequests.shift();if(n){o._closeSteps()}else{o._chunkSteps(r)}}function ReadableStreamGetNumReadRequests(t){return t._reader._readRequests.length}function ReadableStreamHasDefaultReader(t){const r=t._reader;if(r===undefined){return false}if(!IsReadableStreamDefaultReader(r)){return false}return true}class ReadableStreamDefaultReader{constructor(t){assertRequiredArgument(t,1,"ReadableStreamDefaultReader");assertReadableStream(t,"First parameter");if(IsReadableStreamLocked(t)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}ReadableStreamReaderGenericInitialize(this,t);this._readRequests=new SimpleQueue}get closed(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("closed"))}return this._closedPromise}cancel(t=undefined){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,t)}read(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("read"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let t;let r;const n=newPromise(((n,a)=>{t=n;r=a}));const a={_chunkSteps:r=>t({value:r,done:false}),_closeSteps:()=>t({value:undefined,done:true}),_errorSteps:t=>r(t)};ReadableStreamDefaultReaderRead(this,a);return n}releaseLock(){if(!IsReadableStreamDefaultReader(this)){throw defaultReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}ReadableStreamDefaultReaderRelease(this)}}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});setFunctionName(ReadableStreamDefaultReader.prototype.cancel,"cancel");setFunctionName(ReadableStreamDefaultReader.prototype.read,"read");setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock,"releaseLock");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultReader.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:true})}function IsReadableStreamDefaultReader(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_readRequests")){return false}return t instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(t,r){const n=t._ownerReadableStream;n._disturbed=true;if(n._state==="closed"){r._closeSteps()}else if(n._state==="errored"){r._errorSteps(n._storedError)}else{n._readableStreamController[d](r)}}function ReadableStreamDefaultReaderRelease(t){ReadableStreamReaderGenericRelease(t);const r=new TypeError("Reader was released");ReadableStreamDefaultReaderErrorReadRequests(t,r)}function ReadableStreamDefaultReaderErrorReadRequests(t,r){const n=t._readRequests;t._readRequests=new SimpleQueue;n.forEach((t=>{t._errorSteps(r)}))}function defaultReaderBrandCheckException(t){return new TypeError(`ReadableStreamDefaultReader.prototype.${t} can only be used on a ReadableStreamDefaultReader`)}const h=Object.getPrototypeOf(Object.getPrototypeOf((async function*(){})).prototype);class ReadableStreamAsyncIteratorImpl{constructor(t,r){this._ongoingPromise=undefined;this._isFinished=false;this._reader=t;this._preventCancel=r}next(){const nextSteps=()=>this._nextSteps();this._ongoingPromise=this._ongoingPromise?transformPromiseWith(this._ongoingPromise,nextSteps,nextSteps):nextSteps();return this._ongoingPromise}return(t){const returnSteps=()=>this._returnSteps(t);return this._ongoingPromise?transformPromiseWith(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){if(this._isFinished){return Promise.resolve({value:undefined,done:true})}const t=this._reader;let r;let n;const a=newPromise(((t,a)=>{r=t;n=a}));const o={_chunkSteps:t=>{this._ongoingPromise=undefined;_queueMicrotask((()=>r({value:t,done:false})))},_closeSteps:()=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(t);r({value:undefined,done:true})},_errorSteps:r=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(t);n(r)}};ReadableStreamDefaultReaderRead(t,o);return a}_returnSteps(t){if(this._isFinished){return Promise.resolve({value:t,done:true})}this._isFinished=true;const r=this._reader;if(!this._preventCancel){const n=ReadableStreamReaderGenericCancel(r,t);ReadableStreamReaderGenericRelease(r);return transformPromiseWith(n,(()=>({value:t,done:true})))}ReadableStreamReaderGenericRelease(r);return promiseResolvedWith({value:t,done:true})}}const p={next(){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"))}return this._asyncIteratorImpl.next()},return(t){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"))}return this._asyncIteratorImpl.return(t)}};Object.setPrototypeOf(p,h);function AcquireReadableStreamAsyncIterator(t,r){const n=AcquireReadableStreamDefaultReader(t);const a=new ReadableStreamAsyncIteratorImpl(n,r);const o=Object.create(p);o._asyncIteratorImpl=a;return o}function IsReadableStreamAsyncIterator(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_asyncIteratorImpl")){return false}try{return t._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(t){return false}}function streamAsyncIteratorBrandCheckException(t){return new TypeError(`ReadableStreamAsyncIterator.${t} can only be used on a ReadableSteamAsyncIterator`)}const S=Number.isNaN||function(t){return t!==t};var y,R,g;function CreateArrayFromList(t){return t.slice()}function CopyDataBlockBytes(t,r,n,a,o){new Uint8Array(t).set(new Uint8Array(n,a,o),r)}let TransferArrayBuffer=t=>{if(typeof t.transfer==="function"){TransferArrayBuffer=t=>t.transfer()}else if(typeof structuredClone==="function"){TransferArrayBuffer=t=>structuredClone(t,{transfer:[t]})}else{TransferArrayBuffer=t=>t}return TransferArrayBuffer(t)};let IsDetachedBuffer=t=>{if(typeof t.detached==="boolean"){IsDetachedBuffer=t=>t.detached}else{IsDetachedBuffer=t=>t.byteLength===0}return IsDetachedBuffer(t)};function ArrayBufferSlice(t,r,n){if(t.slice){return t.slice(r,n)}const a=n-r;const o=new ArrayBuffer(a);CopyDataBlockBytes(o,0,t,r,a);return o}function GetMethod(t,r){const n=t[r];if(n===undefined||n===null){return undefined}if(typeof n!=="function"){throw new TypeError(`${String(r)} is not a function`)}return n}function CreateAsyncFromSyncIterator(t){const r={[Symbol.iterator]:()=>t.iterator};const n=async function*(){return yield*r}();const a=n.next;return{iterator:n,nextMethod:a,done:false}}const _=(g=(y=Symbol.asyncIterator)!==null&&y!==void 0?y:(R=Symbol.for)===null||R===void 0?void 0:R.call(Symbol,"Symbol.asyncIterator"))!==null&&g!==void 0?g:"@@asyncIterator";function GetIterator(t,r="sync",n){if(n===undefined){if(r==="async"){n=GetMethod(t,_);if(n===undefined){const r=GetMethod(t,Symbol.iterator);const n=GetIterator(t,"sync",r);return CreateAsyncFromSyncIterator(n)}}else{n=GetMethod(t,Symbol.iterator)}}if(n===undefined){throw new TypeError("The object is not iterable")}const a=reflectCall(n,t,[]);if(!typeIsObject(a)){throw new TypeError("The iterator method must return an object")}const o=a.next;return{iterator:a,nextMethod:o,done:false}}function IteratorNext(t){const r=reflectCall(t.nextMethod,t.iterator,[]);if(!typeIsObject(r)){throw new TypeError("The iterator.next() method must return an object")}return r}function IteratorComplete(t){return Boolean(t.done)}function IteratorValue(t){return t.value}function IsNonNegativeNumber(t){if(typeof t!=="number"){return false}if(S(t)){return false}if(t<0){return false}return true}function CloneAsUint8Array(t){const r=ArrayBufferSlice(t.buffer,t.byteOffset,t.byteOffset+t.byteLength);return new Uint8Array(r)}function DequeueValue(t){const r=t._queue.shift();t._queueTotalSize-=r.size;if(t._queueTotalSize<0){t._queueTotalSize=0}return r.value}function EnqueueValueWithSize(t,r,n){if(!IsNonNegativeNumber(n)||n===Infinity){throw new RangeError("Size must be a finite, non-NaN, non-negative number.")}t._queue.push({value:r,size:n});t._queueTotalSize+=n}function PeekQueueValue(t){const r=t._queue.peek();return r.value}function ResetQueue(t){t._queue=new SimpleQueue;t._queueTotalSize=0}function isDataViewConstructor(t){return t===DataView}function isDataView(t){return isDataViewConstructor(t.constructor)}function arrayBufferViewElementSize(t){if(isDataViewConstructor(t)){return 1}return t.BYTES_PER_ELEMENT}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("view")}return this._view}respond(t){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respond")}assertRequiredArgument(t,1,"respond");t=convertUnsignedLongLongWithEnforceRange(t,"First parameter");if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(this._view.buffer)){throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`)}ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,t)}respondWithNewView(t){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respondWithNewView")}assertRequiredArgument(t,1,"respondWithNewView");if(!ArrayBuffer.isView(t)){throw new TypeError("You can only respond with array buffer views")}if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(t.buffer)){throw new TypeError("The given view's buffer has been detached and so cannot be used as a response")}ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,t)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:true},respondWithNewView:{enumerable:true},view:{enumerable:true}});setFunctionName(ReadableStreamBYOBRequest.prototype.respond,"respond");setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView,"respondWithNewView");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBRequest.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:true})}class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("byobRequest")}return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("desiredSize")}return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("close")}if(this._closeRequested){throw new TypeError("The stream has already been closed; do not close it again!")}const t=this._controlledReadableByteStream._state;if(t!=="readable"){throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`)}ReadableByteStreamControllerClose(this)}enqueue(t){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("enqueue")}assertRequiredArgument(t,1,"enqueue");if(!ArrayBuffer.isView(t)){throw new TypeError("chunk must be an array buffer view")}if(t.byteLength===0){throw new TypeError("chunk must have non-zero byteLength")}if(t.buffer.byteLength===0){throw new TypeError(`chunk's buffer must have non-zero byteLength`)}if(this._closeRequested){throw new TypeError("stream is closed or draining")}const r=this._controlledReadableByteStream._state;if(r!=="readable"){throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`)}ReadableByteStreamControllerEnqueue(this,t)}error(t=undefined){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("error")}ReadableByteStreamControllerError(this,t)}[u](t){ReadableByteStreamControllerClearPendingPullIntos(this);ResetQueue(this);const r=this._cancelAlgorithm(t);ReadableByteStreamControllerClearAlgorithms(this);return r}[d](t){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){ReadableByteStreamControllerFillReadRequestFromQueue(this,t);return}const n=this._autoAllocateChunkSize;if(n!==undefined){let r;try{r=new ArrayBuffer(n)}catch(r){t._errorSteps(r);return}const a={buffer:r,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(a)}ReadableStreamAddReadRequest(r,t);ReadableByteStreamControllerCallPullIfNeeded(this)}[c](){if(this._pendingPullIntos.length>0){const t=this._pendingPullIntos.peek();t.readerType="none";this._pendingPullIntos=new SimpleQueue;this._pendingPullIntos.push(t)}}}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},byobRequest:{enumerable:true},desiredSize:{enumerable:true}});setFunctionName(ReadableByteStreamController.prototype.close,"close");setFunctionName(ReadableByteStreamController.prototype.enqueue,"enqueue");setFunctionName(ReadableByteStreamController.prototype.error,"error");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ReadableByteStreamController.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:true})}function IsReadableByteStreamController(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_controlledReadableByteStream")){return false}return t instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_associatedReadableByteStreamController")){return false}return t instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(t){const r=ReadableByteStreamControllerShouldCallPull(t);if(!r){return}if(t._pulling){t._pullAgain=true;return}t._pulling=true;const n=t._pullAlgorithm();uponPromise(n,(()=>{t._pulling=false;if(t._pullAgain){t._pullAgain=false;ReadableByteStreamControllerCallPullIfNeeded(t)}return null}),(r=>{ReadableByteStreamControllerError(t,r);return null}))}function ReadableByteStreamControllerClearPendingPullIntos(t){ReadableByteStreamControllerInvalidateBYOBRequest(t);t._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(t,r){let n=false;if(t._state==="closed"){n=true}const a=ReadableByteStreamControllerConvertPullIntoDescriptor(r);if(r.readerType==="default"){ReadableStreamFulfillReadRequest(t,a,n)}else{ReadableStreamFulfillReadIntoRequest(t,a,n)}}function ReadableByteStreamControllerConvertPullIntoDescriptor(t){const r=t.bytesFilled;const n=t.elementSize;return new t.viewConstructor(t.buffer,t.byteOffset,r/n)}function ReadableByteStreamControllerEnqueueChunkToQueue(t,r,n,a){t._queue.push({buffer:r,byteOffset:n,byteLength:a});t._queueTotalSize+=a}function ReadableByteStreamControllerEnqueueClonedChunkToQueue(t,r,n,a){let o;try{o=ArrayBufferSlice(r,n,n+a)}catch(r){ReadableByteStreamControllerError(t,r);throw r}ReadableByteStreamControllerEnqueueChunkToQueue(t,o,0,a)}function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(t,r){if(r.bytesFilled>0){ReadableByteStreamControllerEnqueueClonedChunkToQueue(t,r.buffer,r.byteOffset,r.bytesFilled)}ReadableByteStreamControllerShiftPendingPullInto(t)}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(t,r){const n=Math.min(t._queueTotalSize,r.byteLength-r.bytesFilled);const a=r.bytesFilled+n;let o=n;let l=false;const i=a%r.elementSize;const s=a-i;if(s>=r.minimumFill){o=s-r.bytesFilled;l=true}const u=t._queue;while(o>0){const n=u.peek();const a=Math.min(o,n.byteLength);const l=r.byteOffset+r.bytesFilled;CopyDataBlockBytes(r.buffer,l,n.buffer,n.byteOffset,a);if(n.byteLength===a){u.shift()}else{n.byteOffset+=a;n.byteLength-=a}t._queueTotalSize-=a;ReadableByteStreamControllerFillHeadPullIntoDescriptor(t,a,r);o-=a}return l}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(t,r,n){n.bytesFilled+=r}function ReadableByteStreamControllerHandleQueueDrain(t){if(t._queueTotalSize===0&&t._closeRequested){ReadableByteStreamControllerClearAlgorithms(t);ReadableStreamClose(t._controlledReadableByteStream)}else{ReadableByteStreamControllerCallPullIfNeeded(t)}}function ReadableByteStreamControllerInvalidateBYOBRequest(t){if(t._byobRequest===null){return}t._byobRequest._associatedReadableByteStreamController=undefined;t._byobRequest._view=null;t._byobRequest=null}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t){while(t._pendingPullIntos.length>0){if(t._queueTotalSize===0){return}const r=t._pendingPullIntos.peek();if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(t,r)){ReadableByteStreamControllerShiftPendingPullInto(t);ReadableByteStreamControllerCommitPullIntoDescriptor(t._controlledReadableByteStream,r)}}}function ReadableByteStreamControllerProcessReadRequestsUsingQueue(t){const r=t._controlledReadableByteStream._reader;while(r._readRequests.length>0){if(t._queueTotalSize===0){return}const n=r._readRequests.shift();ReadableByteStreamControllerFillReadRequestFromQueue(t,n)}}function ReadableByteStreamControllerPullInto(t,r,n,a){const o=t._controlledReadableByteStream;const l=r.constructor;const i=arrayBufferViewElementSize(l);const{byteOffset:s,byteLength:u}=r;const d=n*i;let c;try{c=TransferArrayBuffer(r.buffer)}catch(t){a._errorSteps(t);return}const m={buffer:c,bufferByteLength:c.byteLength,byteOffset:s,byteLength:u,bytesFilled:0,minimumFill:d,elementSize:i,viewConstructor:l,readerType:"byob"};if(t._pendingPullIntos.length>0){t._pendingPullIntos.push(m);ReadableStreamAddReadIntoRequest(o,a);return}if(o._state==="closed"){const t=new l(m.buffer,m.byteOffset,0);a._closeSteps(t);return}if(t._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(t,m)){const r=ReadableByteStreamControllerConvertPullIntoDescriptor(m);ReadableByteStreamControllerHandleQueueDrain(t);a._chunkSteps(r);return}if(t._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(t,r);a._errorSteps(r);return}}t._pendingPullIntos.push(m);ReadableStreamAddReadIntoRequest(o,a);ReadableByteStreamControllerCallPullIfNeeded(t)}function ReadableByteStreamControllerRespondInClosedState(t,r){if(r.readerType==="none"){ReadableByteStreamControllerShiftPendingPullInto(t)}const n=t._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(n)){while(ReadableStreamGetNumReadIntoRequests(n)>0){const r=ReadableByteStreamControllerShiftPendingPullInto(t);ReadableByteStreamControllerCommitPullIntoDescriptor(n,r)}}}function ReadableByteStreamControllerRespondInReadableState(t,r,n){ReadableByteStreamControllerFillHeadPullIntoDescriptor(t,r,n);if(n.readerType==="none"){ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(t,n);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t);return}if(n.bytesFilled<n.minimumFill){return}ReadableByteStreamControllerShiftPendingPullInto(t);const a=n.bytesFilled%n.elementSize;if(a>0){const r=n.byteOffset+n.bytesFilled;ReadableByteStreamControllerEnqueueClonedChunkToQueue(t,n.buffer,r-a,a)}n.bytesFilled-=a;ReadableByteStreamControllerCommitPullIntoDescriptor(t._controlledReadableByteStream,n);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t)}function ReadableByteStreamControllerRespondInternal(t,r){const n=t._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(t);const a=t._controlledReadableByteStream._state;if(a==="closed"){ReadableByteStreamControllerRespondInClosedState(t,n)}else{ReadableByteStreamControllerRespondInReadableState(t,r,n)}ReadableByteStreamControllerCallPullIfNeeded(t)}function ReadableByteStreamControllerShiftPendingPullInto(t){const r=t._pendingPullIntos.shift();return r}function ReadableByteStreamControllerShouldCallPull(t){const r=t._controlledReadableByteStream;if(r._state!=="readable"){return false}if(t._closeRequested){return false}if(!t._started){return false}if(ReadableStreamHasDefaultReader(r)&&ReadableStreamGetNumReadRequests(r)>0){return true}if(ReadableStreamHasBYOBReader(r)&&ReadableStreamGetNumReadIntoRequests(r)>0){return true}const n=ReadableByteStreamControllerGetDesiredSize(t);if(n>0){return true}return false}function ReadableByteStreamControllerClearAlgorithms(t){t._pullAlgorithm=undefined;t._cancelAlgorithm=undefined}function ReadableByteStreamControllerClose(t){const r=t._controlledReadableByteStream;if(t._closeRequested||r._state!=="readable"){return}if(t._queueTotalSize>0){t._closeRequested=true;return}if(t._pendingPullIntos.length>0){const r=t._pendingPullIntos.peek();if(r.bytesFilled%r.elementSize!==0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(t,r);throw r}}ReadableByteStreamControllerClearAlgorithms(t);ReadableStreamClose(r)}function ReadableByteStreamControllerEnqueue(t,r){const n=t._controlledReadableByteStream;if(t._closeRequested||n._state!=="readable"){return}const{buffer:a,byteOffset:o,byteLength:l}=r;if(IsDetachedBuffer(a)){throw new TypeError("chunk's buffer is detached and so cannot be enqueued")}const i=TransferArrayBuffer(a);if(t._pendingPullIntos.length>0){const r=t._pendingPullIntos.peek();if(IsDetachedBuffer(r.buffer)){throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk")}ReadableByteStreamControllerInvalidateBYOBRequest(t);r.buffer=TransferArrayBuffer(r.buffer);if(r.readerType==="none"){ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(t,r)}}if(ReadableStreamHasDefaultReader(n)){ReadableByteStreamControllerProcessReadRequestsUsingQueue(t);if(ReadableStreamGetNumReadRequests(n)===0){ReadableByteStreamControllerEnqueueChunkToQueue(t,i,o,l)}else{if(t._pendingPullIntos.length>0){ReadableByteStreamControllerShiftPendingPullInto(t)}const r=new Uint8Array(i,o,l);ReadableStreamFulfillReadRequest(n,r,false)}}else if(ReadableStreamHasBYOBReader(n)){ReadableByteStreamControllerEnqueueChunkToQueue(t,i,o,l);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t)}else{ReadableByteStreamControllerEnqueueChunkToQueue(t,i,o,l)}ReadableByteStreamControllerCallPullIfNeeded(t)}function ReadableByteStreamControllerError(t,r){const n=t._controlledReadableByteStream;if(n._state!=="readable"){return}ReadableByteStreamControllerClearPendingPullIntos(t);ResetQueue(t);ReadableByteStreamControllerClearAlgorithms(t);ReadableStreamError(n,r)}function ReadableByteStreamControllerFillReadRequestFromQueue(t,r){const n=t._queue.shift();t._queueTotalSize-=n.byteLength;ReadableByteStreamControllerHandleQueueDrain(t);const a=new Uint8Array(n.buffer,n.byteOffset,n.byteLength);r._chunkSteps(a)}function ReadableByteStreamControllerGetBYOBRequest(t){if(t._byobRequest===null&&t._pendingPullIntos.length>0){const r=t._pendingPullIntos.peek();const n=new Uint8Array(r.buffer,r.byteOffset+r.bytesFilled,r.byteLength-r.bytesFilled);const a=Object.create(ReadableStreamBYOBRequest.prototype);SetUpReadableStreamBYOBRequest(a,t,n);t._byobRequest=a}return t._byobRequest}function ReadableByteStreamControllerGetDesiredSize(t){const r=t._controlledReadableByteStream._state;if(r==="errored"){return null}if(r==="closed"){return 0}return t._strategyHWM-t._queueTotalSize}function ReadableByteStreamControllerRespond(t,r){const n=t._pendingPullIntos.peek();const a=t._controlledReadableByteStream._state;if(a==="closed"){if(r!==0){throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}}else{if(r===0){throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream")}if(n.bytesFilled+r>n.byteLength){throw new RangeError("bytesWritten out of range")}}n.buffer=TransferArrayBuffer(n.buffer);ReadableByteStreamControllerRespondInternal(t,r)}function ReadableByteStreamControllerRespondWithNewView(t,r){const n=t._pendingPullIntos.peek();const a=t._controlledReadableByteStream._state;if(a==="closed"){if(r.byteLength!==0){throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}}else{if(r.byteLength===0){throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream")}}if(n.byteOffset+n.bytesFilled!==r.byteOffset){throw new RangeError("The region specified by view does not match byobRequest")}if(n.bufferByteLength!==r.buffer.byteLength){throw new RangeError("The buffer of view has different capacity than byobRequest")}if(n.bytesFilled+r.byteLength>n.byteLength){throw new RangeError("The region specified by view is larger than byobRequest")}const o=r.byteLength;n.buffer=TransferArrayBuffer(r.buffer);ReadableByteStreamControllerRespondInternal(t,o)}function SetUpReadableByteStreamController(t,r,n,a,o,l,i){r._controlledReadableByteStream=t;r._pullAgain=false;r._pulling=false;r._byobRequest=null;r._queue=r._queueTotalSize=undefined;ResetQueue(r);r._closeRequested=false;r._started=false;r._strategyHWM=l;r._pullAlgorithm=a;r._cancelAlgorithm=o;r._autoAllocateChunkSize=i;r._pendingPullIntos=new SimpleQueue;t._readableStreamController=r;const s=n();uponPromise(promiseResolvedWith(s),(()=>{r._started=true;ReadableByteStreamControllerCallPullIfNeeded(r);return null}),(t=>{ReadableByteStreamControllerError(r,t);return null}))}function SetUpReadableByteStreamControllerFromUnderlyingSource(t,r,n){const a=Object.create(ReadableByteStreamController.prototype);let o;let l;let i;if(r.start!==undefined){o=()=>r.start(a)}else{o=()=>undefined}if(r.pull!==undefined){l=()=>r.pull(a)}else{l=()=>promiseResolvedWith(undefined)}if(r.cancel!==undefined){i=t=>r.cancel(t)}else{i=()=>promiseResolvedWith(undefined)}const s=r.autoAllocateChunkSize;if(s===0){throw new TypeError("autoAllocateChunkSize must be greater than 0")}SetUpReadableByteStreamController(t,a,o,l,i,n,s)}function SetUpReadableStreamBYOBRequest(t,r,n){t._associatedReadableByteStreamController=r;t._view=n}function byobRequestBrandCheckException(t){return new TypeError(`ReadableStreamBYOBRequest.prototype.${t} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(t){return new TypeError(`ReadableByteStreamController.prototype.${t} can only be used on a ReadableByteStreamController`)}function convertReaderOptions(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.mode;return{mode:n===undefined?undefined:convertReadableStreamReaderMode(n,`${r} has member 'mode' that`)}}function convertReadableStreamReaderMode(t,r){t=`${t}`;if(t!=="byob"){throw new TypeError(`${r} '${t}' is not a valid enumeration value for ReadableStreamReaderMode`)}return t}function convertByobReadOptions(t,r){var n;assertDictionary(t,r);const a=(n=t===null||t===void 0?void 0:t.min)!==null&&n!==void 0?n:1;return{min:convertUnsignedLongLongWithEnforceRange(a,`${r} has member 'min' that`)}}function AcquireReadableStreamBYOBReader(t){return new ReadableStreamBYOBReader(t)}function ReadableStreamAddReadIntoRequest(t,r){t._reader._readIntoRequests.push(r)}function ReadableStreamFulfillReadIntoRequest(t,r,n){const a=t._reader;const o=a._readIntoRequests.shift();if(n){o._closeSteps(r)}else{o._chunkSteps(r)}}function ReadableStreamGetNumReadIntoRequests(t){return t._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(t){const r=t._reader;if(r===undefined){return false}if(!IsReadableStreamBYOBReader(r)){return false}return true}class ReadableStreamBYOBReader{constructor(t){assertRequiredArgument(t,1,"ReadableStreamBYOBReader");assertReadableStream(t,"First parameter");if(IsReadableStreamLocked(t)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}if(!IsReadableByteStreamController(t._readableStreamController)){throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte "+"source")}ReadableStreamReaderGenericInitialize(this,t);this._readIntoRequests=new SimpleQueue}get closed(){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("closed"))}return this._closedPromise}cancel(t=undefined){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,t)}read(t,r={}){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("read"))}if(!ArrayBuffer.isView(t)){return promiseRejectedWith(new TypeError("view must be an array buffer view"))}if(t.byteLength===0){return promiseRejectedWith(new TypeError("view must have non-zero byteLength"))}if(t.buffer.byteLength===0){return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`))}if(IsDetachedBuffer(t.buffer)){return promiseRejectedWith(new TypeError("view's buffer has been detached"))}let n;try{n=convertByobReadOptions(r,"options")}catch(t){return promiseRejectedWith(t)}const a=n.min;if(a===0){return promiseRejectedWith(new TypeError("options.min must be greater than 0"))}if(!isDataView(t)){if(a>t.length){return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"))}}else if(a>t.byteLength){return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let o;let l;const i=newPromise(((t,r)=>{o=t;l=r}));const s={_chunkSteps:t=>o({value:t,done:false}),_closeSteps:t=>o({value:t,done:true}),_errorSteps:t=>l(t)};ReadableStreamBYOBReaderRead(this,t,a,s);return i}releaseLock(){if(!IsReadableStreamBYOBReader(this)){throw byobReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}ReadableStreamBYOBReaderRelease(this)}}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});setFunctionName(ReadableStreamBYOBReader.prototype.cancel,"cancel");setFunctionName(ReadableStreamBYOBReader.prototype.read,"read");setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock,"releaseLock");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBReader.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:true})}function IsReadableStreamBYOBReader(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_readIntoRequests")){return false}return t instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(t,r,n,a){const o=t._ownerReadableStream;o._disturbed=true;if(o._state==="errored"){a._errorSteps(o._storedError)}else{ReadableByteStreamControllerPullInto(o._readableStreamController,r,n,a)}}function ReadableStreamBYOBReaderRelease(t){ReadableStreamReaderGenericRelease(t);const r=new TypeError("Reader was released");ReadableStreamBYOBReaderErrorReadIntoRequests(t,r)}function ReadableStreamBYOBReaderErrorReadIntoRequests(t,r){const n=t._readIntoRequests;t._readIntoRequests=new SimpleQueue;n.forEach((t=>{t._errorSteps(r)}))}function byobReaderBrandCheckException(t){return new TypeError(`ReadableStreamBYOBReader.prototype.${t} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(t,r){const{highWaterMark:n}=t;if(n===undefined){return r}if(S(n)||n<0){throw new RangeError("Invalid highWaterMark")}return n}function ExtractSizeAlgorithm(t){const{size:r}=t;if(!r){return()=>1}return r}function convertQueuingStrategy(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.highWaterMark;const a=t===null||t===void 0?void 0:t.size;return{highWaterMark:n===undefined?undefined:convertUnrestrictedDouble(n),size:a===undefined?undefined:convertQueuingStrategySize(a,`${r} has member 'size' that`)}}function convertQueuingStrategySize(t,r){assertFunction(t,r);return r=>convertUnrestrictedDouble(t(r))}function convertUnderlyingSink(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.abort;const a=t===null||t===void 0?void 0:t.close;const o=t===null||t===void 0?void 0:t.start;const l=t===null||t===void 0?void 0:t.type;const i=t===null||t===void 0?void 0:t.write;return{abort:n===undefined?undefined:convertUnderlyingSinkAbortCallback(n,t,`${r} has member 'abort' that`),close:a===undefined?undefined:convertUnderlyingSinkCloseCallback(a,t,`${r} has member 'close' that`),start:o===undefined?undefined:convertUnderlyingSinkStartCallback(o,t,`${r} has member 'start' that`),write:i===undefined?undefined:convertUnderlyingSinkWriteCallback(i,t,`${r} has member 'write' that`),type:l}}function convertUnderlyingSinkAbortCallback(t,r,n){assertFunction(t,n);return n=>promiseCall(t,r,[n])}function convertUnderlyingSinkCloseCallback(t,r,n){assertFunction(t,n);return()=>promiseCall(t,r,[])}function convertUnderlyingSinkStartCallback(t,r,n){assertFunction(t,n);return n=>reflectCall(t,r,[n])}function convertUnderlyingSinkWriteCallback(t,r,n){assertFunction(t,n);return(n,a)=>promiseCall(t,r,[n,a])}function assertWritableStream(t,r){if(!IsWritableStream(t)){throw new TypeError(`${r} is not a WritableStream.`)}}function isAbortSignal(t){if(typeof t!=="object"||t===null){return false}try{return typeof t.aborted==="boolean"}catch(t){return false}}const C=typeof AbortController==="function";function createAbortController(){if(C){return new AbortController}return undefined}class WritableStream{constructor(t={},r={}){if(t===undefined){t=null}else{assertObject(t,"First parameter")}const n=convertQueuingStrategy(r,"Second parameter");const a=convertUnderlyingSink(t,"First parameter");InitializeWritableStream(this);const o=a.type;if(o!==undefined){throw new RangeError("Invalid type is specified")}const l=ExtractSizeAlgorithm(n);const i=ExtractHighWaterMark(n,1);SetUpWritableStreamDefaultControllerFromUnderlyingSink(this,a,i,l)}get locked(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("locked")}return IsWritableStreamLocked(this)}abort(t=undefined){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("abort"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"))}return WritableStreamAbort(this,t)}close(){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("close"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"))}if(WritableStreamCloseQueuedOrInFlight(this)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamClose(this)}getWriter(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("getWriter")}return AcquireWritableStreamDefaultWriter(this)}}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:true},close:{enumerable:true},getWriter:{enumerable:true},locked:{enumerable:true}});setFunctionName(WritableStream.prototype.abort,"abort");setFunctionName(WritableStream.prototype.close,"close");setFunctionName(WritableStream.prototype.getWriter,"getWriter");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(WritableStream.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:true})}function AcquireWritableStreamDefaultWriter(t){return new WritableStreamDefaultWriter(t)}function CreateWritableStream(t,r,n,a,o=1,l=(()=>1)){const i=Object.create(WritableStream.prototype);InitializeWritableStream(i);const s=Object.create(WritableStreamDefaultController.prototype);SetUpWritableStreamDefaultController(i,s,t,r,n,a,o,l);return i}function InitializeWritableStream(t){t._state="writable";t._storedError=undefined;t._writer=undefined;t._writableStreamController=undefined;t._writeRequests=new SimpleQueue;t._inFlightWriteRequest=undefined;t._closeRequest=undefined;t._inFlightCloseRequest=undefined;t._pendingAbortRequest=undefined;t._backpressure=false}function IsWritableStream(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_writableStreamController")){return false}return t instanceof WritableStream}function IsWritableStreamLocked(t){if(t._writer===undefined){return false}return true}function WritableStreamAbort(t,r){var n;if(t._state==="closed"||t._state==="errored"){return promiseResolvedWith(undefined)}t._writableStreamController._abortReason=r;(n=t._writableStreamController._abortController)===null||n===void 0?void 0:n.abort(r);const a=t._state;if(a==="closed"||a==="errored"){return promiseResolvedWith(undefined)}if(t._pendingAbortRequest!==undefined){return t._pendingAbortRequest._promise}let o=false;if(a==="erroring"){o=true;r=undefined}const l=newPromise(((n,a)=>{t._pendingAbortRequest={_promise:undefined,_resolve:n,_reject:a,_reason:r,_wasAlreadyErroring:o}}));t._pendingAbortRequest._promise=l;if(!o){WritableStreamStartErroring(t,r)}return l}function WritableStreamClose(t){const r=t._state;if(r==="closed"||r==="errored"){return promiseRejectedWith(new TypeError(`The stream (in ${r} state) is not in the writable state and cannot be closed`))}const n=newPromise(((r,n)=>{const a={_resolve:r,_reject:n};t._closeRequest=a}));const a=t._writer;if(a!==undefined&&t._backpressure&&r==="writable"){defaultWriterReadyPromiseResolve(a)}WritableStreamDefaultControllerClose(t._writableStreamController);return n}function WritableStreamAddWriteRequest(t){const r=newPromise(((r,n)=>{const a={_resolve:r,_reject:n};t._writeRequests.push(a)}));return r}function WritableStreamDealWithRejection(t,r){const n=t._state;if(n==="writable"){WritableStreamStartErroring(t,r);return}WritableStreamFinishErroring(t)}function WritableStreamStartErroring(t,r){const n=t._writableStreamController;t._state="erroring";t._storedError=r;const a=t._writer;if(a!==undefined){WritableStreamDefaultWriterEnsureReadyPromiseRejected(a,r)}if(!WritableStreamHasOperationMarkedInFlight(t)&&n._started){WritableStreamFinishErroring(t)}}function WritableStreamFinishErroring(t){t._state="errored";t._writableStreamController[s]();const r=t._storedError;t._writeRequests.forEach((t=>{t._reject(r)}));t._writeRequests=new SimpleQueue;if(t._pendingAbortRequest===undefined){WritableStreamRejectCloseAndClosedPromiseIfNeeded(t);return}const n=t._pendingAbortRequest;t._pendingAbortRequest=undefined;if(n._wasAlreadyErroring){n._reject(r);WritableStreamRejectCloseAndClosedPromiseIfNeeded(t);return}const a=t._writableStreamController[i](n._reason);uponPromise(a,(()=>{n._resolve();WritableStreamRejectCloseAndClosedPromiseIfNeeded(t);return null}),(r=>{n._reject(r);WritableStreamRejectCloseAndClosedPromiseIfNeeded(t);return null}))}function WritableStreamFinishInFlightWrite(t){t._inFlightWriteRequest._resolve(undefined);t._inFlightWriteRequest=undefined}function WritableStreamFinishInFlightWriteWithError(t,r){t._inFlightWriteRequest._reject(r);t._inFlightWriteRequest=undefined;WritableStreamDealWithRejection(t,r)}function WritableStreamFinishInFlightClose(t){t._inFlightCloseRequest._resolve(undefined);t._inFlightCloseRequest=undefined;const r=t._state;if(r==="erroring"){t._storedError=undefined;if(t._pendingAbortRequest!==undefined){t._pendingAbortRequest._resolve();t._pendingAbortRequest=undefined}}t._state="closed";const n=t._writer;if(n!==undefined){defaultWriterClosedPromiseResolve(n)}}function WritableStreamFinishInFlightCloseWithError(t,r){t._inFlightCloseRequest._reject(r);t._inFlightCloseRequest=undefined;if(t._pendingAbortRequest!==undefined){t._pendingAbortRequest._reject(r);t._pendingAbortRequest=undefined}WritableStreamDealWithRejection(t,r)}function WritableStreamCloseQueuedOrInFlight(t){if(t._closeRequest===undefined&&t._inFlightCloseRequest===undefined){return false}return true}function WritableStreamHasOperationMarkedInFlight(t){if(t._inFlightWriteRequest===undefined&&t._inFlightCloseRequest===undefined){return false}return true}function WritableStreamMarkCloseRequestInFlight(t){t._inFlightCloseRequest=t._closeRequest;t._closeRequest=undefined}function WritableStreamMarkFirstWriteRequestInFlight(t){t._inFlightWriteRequest=t._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(t){if(t._closeRequest!==undefined){t._closeRequest._reject(t._storedError);t._closeRequest=undefined}const r=t._writer;if(r!==undefined){defaultWriterClosedPromiseReject(r,t._storedError)}}function WritableStreamUpdateBackpressure(t,r){const n=t._writer;if(n!==undefined&&r!==t._backpressure){if(r){defaultWriterReadyPromiseReset(n)}else{defaultWriterReadyPromiseResolve(n)}}t._backpressure=r}class WritableStreamDefaultWriter{constructor(t){assertRequiredArgument(t,1,"WritableStreamDefaultWriter");assertWritableStream(t,"First parameter");if(IsWritableStreamLocked(t)){throw new TypeError("This stream has already been locked for exclusive writing by another writer")}this._ownerWritableStream=t;t._writer=this;const r=t._state;if(r==="writable"){if(!WritableStreamCloseQueuedOrInFlight(t)&&t._backpressure){defaultWriterReadyPromiseInitialize(this)}else{defaultWriterReadyPromiseInitializeAsResolved(this)}defaultWriterClosedPromiseInitialize(this)}else if(r==="erroring"){defaultWriterReadyPromiseInitializeAsRejected(this,t._storedError);defaultWriterClosedPromiseInitialize(this)}else if(r==="closed"){defaultWriterReadyPromiseInitializeAsResolved(this);defaultWriterClosedPromiseInitializeAsResolved(this)}else{const r=t._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,r);defaultWriterClosedPromiseInitializeAsRejected(this,r)}}get closed(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("closed"))}return this._closedPromise}get desiredSize(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("desiredSize")}if(this._ownerWritableStream===undefined){throw defaultWriterLockException("desiredSize")}return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("ready"))}return this._readyPromise}abort(t=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("abort"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("abort"))}return WritableStreamDefaultWriterAbort(this,t)}close(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("close"))}const t=this._ownerWritableStream;if(t===undefined){return promiseRejectedWith(defaultWriterLockException("close"))}if(WritableStreamCloseQueuedOrInFlight(t)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("releaseLock")}const t=this._ownerWritableStream;if(t===undefined){return}WritableStreamDefaultWriterRelease(this)}write(t=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("write"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("write to"))}return WritableStreamDefaultWriterWrite(this,t)}}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:true},close:{enumerable:true},releaseLock:{enumerable:true},write:{enumerable:true},closed:{enumerable:true},desiredSize:{enumerable:true},ready:{enumerable:true}});setFunctionName(WritableStreamDefaultWriter.prototype.abort,"abort");setFunctionName(WritableStreamDefaultWriter.prototype.close,"close");setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock,"releaseLock");setFunctionName(WritableStreamDefaultWriter.prototype.write,"write");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultWriter.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:true})}function IsWritableStreamDefaultWriter(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_ownerWritableStream")){return false}return t instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterAbort(t,r){const n=t._ownerWritableStream;return WritableStreamAbort(n,r)}function WritableStreamDefaultWriterClose(t){const r=t._ownerWritableStream;return WritableStreamClose(r)}function WritableStreamDefaultWriterCloseWithErrorPropagation(t){const r=t._ownerWritableStream;const n=r._state;if(WritableStreamCloseQueuedOrInFlight(r)||n==="closed"){return promiseResolvedWith(undefined)}if(n==="errored"){return promiseRejectedWith(r._storedError)}return WritableStreamDefaultWriterClose(t)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(t,r){if(t._closedPromiseState==="pending"){defaultWriterClosedPromiseReject(t,r)}else{defaultWriterClosedPromiseResetToRejected(t,r)}}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(t,r){if(t._readyPromiseState==="pending"){defaultWriterReadyPromiseReject(t,r)}else{defaultWriterReadyPromiseResetToRejected(t,r)}}function WritableStreamDefaultWriterGetDesiredSize(t){const r=t._ownerWritableStream;const n=r._state;if(n==="errored"||n==="erroring"){return null}if(n==="closed"){return 0}return WritableStreamDefaultControllerGetDesiredSize(r._writableStreamController)}function WritableStreamDefaultWriterRelease(t){const r=t._ownerWritableStream;const n=new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);WritableStreamDefaultWriterEnsureReadyPromiseRejected(t,n);WritableStreamDefaultWriterEnsureClosedPromiseRejected(t,n);r._writer=undefined;t._ownerWritableStream=undefined}function WritableStreamDefaultWriterWrite(t,r){const n=t._ownerWritableStream;const a=n._writableStreamController;const o=WritableStreamDefaultControllerGetChunkSize(a,r);if(n!==t._ownerWritableStream){return promiseRejectedWith(defaultWriterLockException("write to"))}const l=n._state;if(l==="errored"){return promiseRejectedWith(n._storedError)}if(WritableStreamCloseQueuedOrInFlight(n)||l==="closed"){return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"))}if(l==="erroring"){return promiseRejectedWith(n._storedError)}const i=WritableStreamAddWriteRequest(n);WritableStreamDefaultControllerWrite(a,r,o);return i}const w={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("abortReason")}return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("signal")}if(this._abortController===undefined){throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported")}return this._abortController.signal}error(t=undefined){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("error")}const r=this._controlledWritableStream._state;if(r!=="writable"){return}WritableStreamDefaultControllerError(this,t)}[i](t){const r=this._abortAlgorithm(t);WritableStreamDefaultControllerClearAlgorithms(this);return r}[s](){ResetQueue(this)}}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:true},signal:{enumerable:true},error:{enumerable:true}});if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultController.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:true})}function IsWritableStreamDefaultController(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_controlledWritableStream")){return false}return t instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(t,r,n,a,o,l,i,s){r._controlledWritableStream=t;t._writableStreamController=r;r._queue=undefined;r._queueTotalSize=undefined;ResetQueue(r);r._abortReason=undefined;r._abortController=createAbortController();r._started=false;r._strategySizeAlgorithm=s;r._strategyHWM=i;r._writeAlgorithm=a;r._closeAlgorithm=o;r._abortAlgorithm=l;const u=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(t,u);const d=n();const c=promiseResolvedWith(d);uponPromise(c,(()=>{r._started=true;WritableStreamDefaultControllerAdvanceQueueIfNeeded(r);return null}),(n=>{r._started=true;WritableStreamDealWithRejection(t,n);return null}))}function SetUpWritableStreamDefaultControllerFromUnderlyingSink(t,r,n,a){const o=Object.create(WritableStreamDefaultController.prototype);let l;let i;let s;let u;if(r.start!==undefined){l=()=>r.start(o)}else{l=()=>undefined}if(r.write!==undefined){i=t=>r.write(t,o)}else{i=()=>promiseResolvedWith(undefined)}if(r.close!==undefined){s=()=>r.close()}else{s=()=>promiseResolvedWith(undefined)}if(r.abort!==undefined){u=t=>r.abort(t)}else{u=()=>promiseResolvedWith(undefined)}SetUpWritableStreamDefaultController(t,o,l,i,s,u,n,a)}function WritableStreamDefaultControllerClearAlgorithms(t){t._writeAlgorithm=undefined;t._closeAlgorithm=undefined;t._abortAlgorithm=undefined;t._strategySizeAlgorithm=undefined}function WritableStreamDefaultControllerClose(t){EnqueueValueWithSize(t,w,0);WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)}function WritableStreamDefaultControllerGetChunkSize(t,r){try{return t._strategySizeAlgorithm(r)}catch(r){WritableStreamDefaultControllerErrorIfNeeded(t,r);return 1}}function WritableStreamDefaultControllerGetDesiredSize(t){return t._strategyHWM-t._queueTotalSize}function WritableStreamDefaultControllerWrite(t,r,n){try{EnqueueValueWithSize(t,r,n)}catch(r){WritableStreamDefaultControllerErrorIfNeeded(t,r);return}const a=t._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(a)&&a._state==="writable"){const r=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(a,r)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(t){const r=t._controlledWritableStream;if(!t._started){return}if(r._inFlightWriteRequest!==undefined){return}const n=r._state;if(n==="erroring"){WritableStreamFinishErroring(r);return}if(t._queue.length===0){return}const a=PeekQueueValue(t);if(a===w){WritableStreamDefaultControllerProcessClose(t)}else{WritableStreamDefaultControllerProcessWrite(t,a)}}function WritableStreamDefaultControllerErrorIfNeeded(t,r){if(t._controlledWritableStream._state==="writable"){WritableStreamDefaultControllerError(t,r)}}function WritableStreamDefaultControllerProcessClose(t){const r=t._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(r);DequeueValue(t);const n=t._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(t);uponPromise(n,(()=>{WritableStreamFinishInFlightClose(r);return null}),(t=>{WritableStreamFinishInFlightCloseWithError(r,t);return null}))}function WritableStreamDefaultControllerProcessWrite(t,r){const n=t._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(n);const a=t._writeAlgorithm(r);uponPromise(a,(()=>{WritableStreamFinishInFlightWrite(n);const r=n._state;DequeueValue(t);if(!WritableStreamCloseQueuedOrInFlight(n)&&r==="writable"){const r=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(n,r)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(t);return null}),(r=>{if(n._state==="writable"){WritableStreamDefaultControllerClearAlgorithms(t)}WritableStreamFinishInFlightWriteWithError(n,r);return null}))}function WritableStreamDefaultControllerGetBackpressure(t){const r=WritableStreamDefaultControllerGetDesiredSize(t);return r<=0}function WritableStreamDefaultControllerError(t,r){const n=t._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(t);WritableStreamStartErroring(n,r)}function streamBrandCheckException$2(t){return new TypeError(`WritableStream.prototype.${t} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(t){return new TypeError(`WritableStreamDefaultController.prototype.${t} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(t){return new TypeError(`WritableStreamDefaultWriter.prototype.${t} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(t){return new TypeError("Cannot "+t+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(t){t._closedPromise=newPromise(((r,n)=>{t._closedPromise_resolve=r;t._closedPromise_reject=n;t._closedPromiseState="pending"}))}function defaultWriterClosedPromiseInitializeAsRejected(t,r){defaultWriterClosedPromiseInitialize(t);defaultWriterClosedPromiseReject(t,r)}function defaultWriterClosedPromiseInitializeAsResolved(t){defaultWriterClosedPromiseInitialize(t);defaultWriterClosedPromiseResolve(t)}function defaultWriterClosedPromiseReject(t,r){if(t._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(t._closedPromise);t._closedPromise_reject(r);t._closedPromise_resolve=undefined;t._closedPromise_reject=undefined;t._closedPromiseState="rejected"}function defaultWriterClosedPromiseResetToRejected(t,r){defaultWriterClosedPromiseInitializeAsRejected(t,r)}function defaultWriterClosedPromiseResolve(t){if(t._closedPromise_resolve===undefined){return}t._closedPromise_resolve(undefined);t._closedPromise_resolve=undefined;t._closedPromise_reject=undefined;t._closedPromiseState="resolved"}function defaultWriterReadyPromiseInitialize(t){t._readyPromise=newPromise(((r,n)=>{t._readyPromise_resolve=r;t._readyPromise_reject=n}));t._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(t,r){defaultWriterReadyPromiseInitialize(t);defaultWriterReadyPromiseReject(t,r)}function defaultWriterReadyPromiseInitializeAsResolved(t){defaultWriterReadyPromiseInitialize(t);defaultWriterReadyPromiseResolve(t)}function defaultWriterReadyPromiseReject(t,r){if(t._readyPromise_reject===undefined){return}setPromiseIsHandledToTrue(t._readyPromise);t._readyPromise_reject(r);t._readyPromise_resolve=undefined;t._readyPromise_reject=undefined;t._readyPromiseState="rejected"}function defaultWriterReadyPromiseReset(t){defaultWriterReadyPromiseInitialize(t)}function defaultWriterReadyPromiseResetToRejected(t,r){defaultWriterReadyPromiseInitializeAsRejected(t,r)}function defaultWriterReadyPromiseResolve(t){if(t._readyPromise_resolve===undefined){return}t._readyPromise_resolve(undefined);t._readyPromise_resolve=undefined;t._readyPromise_reject=undefined;t._readyPromiseState="fulfilled"}function getGlobals(){if(typeof globalThis!=="undefined"){return globalThis}else if(typeof self!=="undefined"){return self}else if(typeof global!=="undefined"){return global}return undefined}const W=getGlobals();function isDOMExceptionConstructor(t){if(!(typeof t==="function"||typeof t==="object")){return false}if(t.name!=="DOMException"){return false}try{new t;return true}catch(t){return false}}function getFromGlobal(){const t=W===null||W===void 0?void 0:W.DOMException;return isDOMExceptionConstructor(t)?t:undefined}function createPolyfill(){const t=function DOMException(t,r){this.message=t||"";this.name=r||"Error";if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}};setFunctionName(t,"DOMException");t.prototype=Object.create(Error.prototype);Object.defineProperty(t.prototype,"constructor",{value:t,writable:true,configurable:true});return t}const B=getFromGlobal()||createPolyfill();function ReadableStreamPipeTo(t,r,n,a,o,l){const i=AcquireReadableStreamDefaultReader(t);const s=AcquireWritableStreamDefaultWriter(r);t._disturbed=true;let u=false;let d=promiseResolvedWith(undefined);return newPromise(((c,m)=>{let b;if(l!==undefined){b=()=>{const n=l.reason!==undefined?l.reason:new B("Aborted","AbortError");const i=[];if(!a){i.push((()=>{if(r._state==="writable"){return WritableStreamAbort(r,n)}return promiseResolvedWith(undefined)}))}if(!o){i.push((()=>{if(t._state==="readable"){return ReadableStreamCancel(t,n)}return promiseResolvedWith(undefined)}))}shutdownWithAction((()=>Promise.all(i.map((t=>t())))),true,n)};if(l.aborted){b();return}l.addEventListener("abort",b)}function pipeLoop(){return newPromise(((t,r)=>{function next(n){if(n){t()}else{PerformPromiseThen(pipeStep(),next,r)}}next(false)}))}function pipeStep(){if(u){return promiseResolvedWith(true)}return PerformPromiseThen(s._readyPromise,(()=>newPromise(((t,r)=>{ReadableStreamDefaultReaderRead(i,{_chunkSteps:r=>{d=PerformPromiseThen(WritableStreamDefaultWriterWrite(s,r),undefined,noop);t(false)},_closeSteps:()=>t(true),_errorSteps:r})}))))}isOrBecomesErrored(t,i._closedPromise,(t=>{if(!a){shutdownWithAction((()=>WritableStreamAbort(r,t)),true,t)}else{shutdown(true,t)}return null}));isOrBecomesErrored(r,s._closedPromise,(r=>{if(!o){shutdownWithAction((()=>ReadableStreamCancel(t,r)),true,r)}else{shutdown(true,r)}return null}));isOrBecomesClosed(t,i._closedPromise,(()=>{if(!n){shutdownWithAction((()=>WritableStreamDefaultWriterCloseWithErrorPropagation(s)))}else{shutdown()}return null}));if(WritableStreamCloseQueuedOrInFlight(r)||r._state==="closed"){const r=new TypeError("the destination writable stream closed before all data could be piped to it");if(!o){shutdownWithAction((()=>ReadableStreamCancel(t,r)),true,r)}else{shutdown(true,r)}}setPromiseIsHandledToTrue(pipeLoop());function waitForWritesToFinish(){const t=d;return PerformPromiseThen(d,(()=>t!==d?waitForWritesToFinish():undefined))}function isOrBecomesErrored(t,r,n){if(t._state==="errored"){n(t._storedError)}else{uponRejection(r,n)}}function isOrBecomesClosed(t,r,n){if(t._state==="closed"){n()}else{uponFulfillment(r,n)}}function shutdownWithAction(t,n,a){if(u){return}u=true;if(r._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(r)){uponFulfillment(waitForWritesToFinish(),doTheRest)}else{doTheRest()}function doTheRest(){uponPromise(t(),(()=>finalize(n,a)),(t=>finalize(true,t)));return null}}function shutdown(t,n){if(u){return}u=true;if(r._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(r)){uponFulfillment(waitForWritesToFinish(),(()=>finalize(t,n)))}else{finalize(t,n)}}function finalize(t,r){WritableStreamDefaultWriterRelease(s);ReadableStreamReaderGenericRelease(i);if(l!==undefined){l.removeEventListener("abort",b)}if(t){m(r)}else{c(undefined)}return null}}))}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("desiredSize")}return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("close")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits close")}ReadableStreamDefaultControllerClose(this)}enqueue(t=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("enqueue")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits enqueue")}return ReadableStreamDefaultControllerEnqueue(this,t)}error(t=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("error")}ReadableStreamDefaultControllerError(this,t)}[u](t){ResetQueue(this);const r=this._cancelAlgorithm(t);ReadableStreamDefaultControllerClearAlgorithms(this);return r}[d](t){const r=this._controlledReadableStream;if(this._queue.length>0){const n=DequeueValue(this);if(this._closeRequested&&this._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(this);ReadableStreamClose(r)}else{ReadableStreamDefaultControllerCallPullIfNeeded(this)}t._chunkSteps(n)}else{ReadableStreamAddReadRequest(r,t);ReadableStreamDefaultControllerCallPullIfNeeded(this)}}[c](){}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},desiredSize:{enumerable:true}});setFunctionName(ReadableStreamDefaultController.prototype.close,"close");setFunctionName(ReadableStreamDefaultController.prototype.enqueue,"enqueue");setFunctionName(ReadableStreamDefaultController.prototype.error,"error");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultController.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:true})}function IsReadableStreamDefaultController(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_controlledReadableStream")){return false}return t instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(t){const r=ReadableStreamDefaultControllerShouldCallPull(t);if(!r){return}if(t._pulling){t._pullAgain=true;return}t._pulling=true;const n=t._pullAlgorithm();uponPromise(n,(()=>{t._pulling=false;if(t._pullAgain){t._pullAgain=false;ReadableStreamDefaultControllerCallPullIfNeeded(t)}return null}),(r=>{ReadableStreamDefaultControllerError(t,r);return null}))}function ReadableStreamDefaultControllerShouldCallPull(t){const r=t._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(t)){return false}if(!t._started){return false}if(IsReadableStreamLocked(r)&&ReadableStreamGetNumReadRequests(r)>0){return true}const n=ReadableStreamDefaultControllerGetDesiredSize(t);if(n>0){return true}return false}function ReadableStreamDefaultControllerClearAlgorithms(t){t._pullAlgorithm=undefined;t._cancelAlgorithm=undefined;t._strategySizeAlgorithm=undefined}function ReadableStreamDefaultControllerClose(t){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(t)){return}const r=t._controlledReadableStream;t._closeRequested=true;if(t._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(t);ReadableStreamClose(r)}}function ReadableStreamDefaultControllerEnqueue(t,r){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(t)){return}const n=t._controlledReadableStream;if(IsReadableStreamLocked(n)&&ReadableStreamGetNumReadRequests(n)>0){ReadableStreamFulfillReadRequest(n,r,false)}else{let n;try{n=t._strategySizeAlgorithm(r)}catch(r){ReadableStreamDefaultControllerError(t,r);throw r}try{EnqueueValueWithSize(t,r,n)}catch(r){ReadableStreamDefaultControllerError(t,r);throw r}}ReadableStreamDefaultControllerCallPullIfNeeded(t)}function ReadableStreamDefaultControllerError(t,r){const n=t._controlledReadableStream;if(n._state!=="readable"){return}ResetQueue(t);ReadableStreamDefaultControllerClearAlgorithms(t);ReadableStreamError(n,r)}function ReadableStreamDefaultControllerGetDesiredSize(t){const r=t._controlledReadableStream._state;if(r==="errored"){return null}if(r==="closed"){return 0}return t._strategyHWM-t._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(t){if(ReadableStreamDefaultControllerShouldCallPull(t)){return false}return true}function ReadableStreamDefaultControllerCanCloseOrEnqueue(t){const r=t._controlledReadableStream._state;if(!t._closeRequested&&r==="readable"){return true}return false}function SetUpReadableStreamDefaultController(t,r,n,a,o,l,i){r._controlledReadableStream=t;r._queue=undefined;r._queueTotalSize=undefined;ResetQueue(r);r._started=false;r._closeRequested=false;r._pullAgain=false;r._pulling=false;r._strategySizeAlgorithm=i;r._strategyHWM=l;r._pullAlgorithm=a;r._cancelAlgorithm=o;t._readableStreamController=r;const s=n();uponPromise(promiseResolvedWith(s),(()=>{r._started=true;ReadableStreamDefaultControllerCallPullIfNeeded(r);return null}),(t=>{ReadableStreamDefaultControllerError(r,t);return null}))}function SetUpReadableStreamDefaultControllerFromUnderlyingSource(t,r,n,a){const o=Object.create(ReadableStreamDefaultController.prototype);let l;let i;let s;if(r.start!==undefined){l=()=>r.start(o)}else{l=()=>undefined}if(r.pull!==undefined){i=()=>r.pull(o)}else{i=()=>promiseResolvedWith(undefined)}if(r.cancel!==undefined){s=t=>r.cancel(t)}else{s=()=>promiseResolvedWith(undefined)}SetUpReadableStreamDefaultController(t,o,l,i,s,n,a)}function defaultControllerBrandCheckException$1(t){return new TypeError(`ReadableStreamDefaultController.prototype.${t} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(t,r){if(IsReadableByteStreamController(t._readableStreamController)){return ReadableByteStreamTee(t)}return ReadableStreamDefaultTee(t)}function ReadableStreamDefaultTee(t,r){const n=AcquireReadableStreamDefaultReader(t);let a=false;let o=false;let l=false;let i=false;let s;let u;let d;let c;let m;const b=newPromise((t=>{m=t}));function pullAlgorithm(){if(a){o=true;return promiseResolvedWith(undefined)}a=true;const t={_chunkSteps:t=>{_queueMicrotask((()=>{o=false;const r=t;const n=t;if(!l){ReadableStreamDefaultControllerEnqueue(d._readableStreamController,r)}if(!i){ReadableStreamDefaultControllerEnqueue(c._readableStreamController,n)}a=false;if(o){pullAlgorithm()}}))},_closeSteps:()=>{a=false;if(!l){ReadableStreamDefaultControllerClose(d._readableStreamController)}if(!i){ReadableStreamDefaultControllerClose(c._readableStreamController)}if(!l||!i){m(undefined)}},_errorSteps:()=>{a=false}};ReadableStreamDefaultReaderRead(n,t);return promiseResolvedWith(undefined)}function cancel1Algorithm(r){l=true;s=r;if(i){const r=CreateArrayFromList([s,u]);const n=ReadableStreamCancel(t,r);m(n)}return b}function cancel2Algorithm(r){i=true;u=r;if(l){const r=CreateArrayFromList([s,u]);const n=ReadableStreamCancel(t,r);m(n)}return b}function startAlgorithm(){}d=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel1Algorithm);c=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel2Algorithm);uponRejection(n._closedPromise,(t=>{ReadableStreamDefaultControllerError(d._readableStreamController,t);ReadableStreamDefaultControllerError(c._readableStreamController,t);if(!l||!i){m(undefined)}return null}));return[d,c]}function ReadableByteStreamTee(t){let r=AcquireReadableStreamDefaultReader(t);let n=false;let a=false;let o=false;let l=false;let i=false;let s;let u;let d;let c;let m;const b=newPromise((t=>{m=t}));function forwardReaderError(t){uponRejection(t._closedPromise,(n=>{if(t!==r){return null}ReadableByteStreamControllerError(d._readableStreamController,n);ReadableByteStreamControllerError(c._readableStreamController,n);if(!l||!i){m(undefined)}return null}))}function pullWithDefaultReader(){if(IsReadableStreamBYOBReader(r)){ReadableStreamReaderGenericRelease(r);r=AcquireReadableStreamDefaultReader(t);forwardReaderError(r)}const s={_chunkSteps:r=>{_queueMicrotask((()=>{a=false;o=false;const s=r;let u=r;if(!l&&!i){try{u=CloneAsUint8Array(r)}catch(r){ReadableByteStreamControllerError(d._readableStreamController,r);ReadableByteStreamControllerError(c._readableStreamController,r);m(ReadableStreamCancel(t,r));return}}if(!l){ReadableByteStreamControllerEnqueue(d._readableStreamController,s)}if(!i){ReadableByteStreamControllerEnqueue(c._readableStreamController,u)}n=false;if(a){pull1Algorithm()}else if(o){pull2Algorithm()}}))},_closeSteps:()=>{n=false;if(!l){ReadableByteStreamControllerClose(d._readableStreamController)}if(!i){ReadableByteStreamControllerClose(c._readableStreamController)}if(d._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(d._readableStreamController,0)}if(c._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(c._readableStreamController,0)}if(!l||!i){m(undefined)}},_errorSteps:()=>{n=false}};ReadableStreamDefaultReaderRead(r,s)}function pullWithBYOBReader(s,u){if(IsReadableStreamDefaultReader(r)){ReadableStreamReaderGenericRelease(r);r=AcquireReadableStreamBYOBReader(t);forwardReaderError(r)}const b=u?c:d;const h=u?d:c;const p={_chunkSteps:r=>{_queueMicrotask((()=>{a=false;o=false;const s=u?i:l;const d=u?l:i;if(!d){let n;try{n=CloneAsUint8Array(r)}catch(r){ReadableByteStreamControllerError(b._readableStreamController,r);ReadableByteStreamControllerError(h._readableStreamController,r);m(ReadableStreamCancel(t,r));return}if(!s){ReadableByteStreamControllerRespondWithNewView(b._readableStreamController,r)}ReadableByteStreamControllerEnqueue(h._readableStreamController,n)}else if(!s){ReadableByteStreamControllerRespondWithNewView(b._readableStreamController,r)}n=false;if(a){pull1Algorithm()}else if(o){pull2Algorithm()}}))},_closeSteps:t=>{n=false;const r=u?i:l;const a=u?l:i;if(!r){ReadableByteStreamControllerClose(b._readableStreamController)}if(!a){ReadableByteStreamControllerClose(h._readableStreamController)}if(t!==undefined){if(!r){ReadableByteStreamControllerRespondWithNewView(b._readableStreamController,t)}if(!a&&h._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(h._readableStreamController,0)}}if(!r||!a){m(undefined)}},_errorSteps:()=>{n=false}};ReadableStreamBYOBReaderRead(r,s,1,p)}function pull1Algorithm(){if(n){a=true;return promiseResolvedWith(undefined)}n=true;const t=ReadableByteStreamControllerGetBYOBRequest(d._readableStreamController);if(t===null){pullWithDefaultReader()}else{pullWithBYOBReader(t._view,false)}return promiseResolvedWith(undefined)}function pull2Algorithm(){if(n){o=true;return promiseResolvedWith(undefined)}n=true;const t=ReadableByteStreamControllerGetBYOBRequest(c._readableStreamController);if(t===null){pullWithDefaultReader()}else{pullWithBYOBReader(t._view,true)}return promiseResolvedWith(undefined)}function cancel1Algorithm(r){l=true;s=r;if(i){const r=CreateArrayFromList([s,u]);const n=ReadableStreamCancel(t,r);m(n)}return b}function cancel2Algorithm(r){i=true;u=r;if(l){const r=CreateArrayFromList([s,u]);const n=ReadableStreamCancel(t,r);m(n)}return b}function startAlgorithm(){return}d=CreateReadableByteStream(startAlgorithm,pull1Algorithm,cancel1Algorithm);c=CreateReadableByteStream(startAlgorithm,pull2Algorithm,cancel2Algorithm);forwardReaderError(r);return[d,c]}function isReadableStreamLike(t){return typeIsObject(t)&&typeof t.getReader!=="undefined"}function ReadableStreamFrom(t){if(isReadableStreamLike(t)){return ReadableStreamFromDefaultReader(t.getReader())}return ReadableStreamFromIterable(t)}function ReadableStreamFromIterable(t){let r;const n=GetIterator(t,"async");const a=noop;function pullAlgorithm(){let t;try{t=IteratorNext(n)}catch(t){return promiseRejectedWith(t)}const a=promiseResolvedWith(t);return transformPromiseWith(a,(t=>{if(!typeIsObject(t)){throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object")}const n=IteratorComplete(t);if(n){ReadableStreamDefaultControllerClose(r._readableStreamController)}else{const n=IteratorValue(t);ReadableStreamDefaultControllerEnqueue(r._readableStreamController,n)}}))}function cancelAlgorithm(t){const r=n.iterator;let a;try{a=GetMethod(r,"return")}catch(t){return promiseRejectedWith(t)}if(a===undefined){return promiseResolvedWith(undefined)}let o;try{o=reflectCall(a,r,[t])}catch(t){return promiseRejectedWith(t)}const l=promiseResolvedWith(o);return transformPromiseWith(l,(t=>{if(!typeIsObject(t)){throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")}return undefined}))}r=CreateReadableStream(a,pullAlgorithm,cancelAlgorithm,0);return r}function ReadableStreamFromDefaultReader(t){let r;const n=noop;function pullAlgorithm(){let n;try{n=t.read()}catch(t){return promiseRejectedWith(t)}return transformPromiseWith(n,(t=>{if(!typeIsObject(t)){throw new TypeError("The promise returned by the reader.read() method must fulfill with an object")}if(t.done){ReadableStreamDefaultControllerClose(r._readableStreamController)}else{const n=t.value;ReadableStreamDefaultControllerEnqueue(r._readableStreamController,n)}}))}function cancelAlgorithm(r){try{return promiseResolvedWith(t.cancel(r))}catch(t){return promiseRejectedWith(t)}}r=CreateReadableStream(n,pullAlgorithm,cancelAlgorithm,0);return r}function convertUnderlyingDefaultOrByteSource(t,r){assertDictionary(t,r);const n=t;const a=n===null||n===void 0?void 0:n.autoAllocateChunkSize;const o=n===null||n===void 0?void 0:n.cancel;const l=n===null||n===void 0?void 0:n.pull;const i=n===null||n===void 0?void 0:n.start;const s=n===null||n===void 0?void 0:n.type;return{autoAllocateChunkSize:a===undefined?undefined:convertUnsignedLongLongWithEnforceRange(a,`${r} has member 'autoAllocateChunkSize' that`),cancel:o===undefined?undefined:convertUnderlyingSourceCancelCallback(o,n,`${r} has member 'cancel' that`),pull:l===undefined?undefined:convertUnderlyingSourcePullCallback(l,n,`${r} has member 'pull' that`),start:i===undefined?undefined:convertUnderlyingSourceStartCallback(i,n,`${r} has member 'start' that`),type:s===undefined?undefined:convertReadableStreamType(s,`${r} has member 'type' that`)}}function convertUnderlyingSourceCancelCallback(t,r,n){assertFunction(t,n);return n=>promiseCall(t,r,[n])}function convertUnderlyingSourcePullCallback(t,r,n){assertFunction(t,n);return n=>promiseCall(t,r,[n])}function convertUnderlyingSourceStartCallback(t,r,n){assertFunction(t,n);return n=>reflectCall(t,r,[n])}function convertReadableStreamType(t,r){t=`${t}`;if(t!=="bytes"){throw new TypeError(`${r} '${t}' is not a valid enumeration value for ReadableStreamType`)}return t}function convertIteratorOptions(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.preventCancel;return{preventCancel:Boolean(n)}}function convertPipeOptions(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.preventAbort;const a=t===null||t===void 0?void 0:t.preventCancel;const o=t===null||t===void 0?void 0:t.preventClose;const l=t===null||t===void 0?void 0:t.signal;if(l!==undefined){assertAbortSignal(l,`${r} has member 'signal' that`)}return{preventAbort:Boolean(n),preventCancel:Boolean(a),preventClose:Boolean(o),signal:l}}function assertAbortSignal(t,r){if(!isAbortSignal(t)){throw new TypeError(`${r} is not an AbortSignal.`)}}function convertReadableWritablePair(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.readable;assertRequiredField(n,"readable","ReadableWritablePair");assertReadableStream(n,`${r} has member 'readable' that`);const a=t===null||t===void 0?void 0:t.writable;assertRequiredField(a,"writable","ReadableWritablePair");assertWritableStream(a,`${r} has member 'writable' that`);return{readable:n,writable:a}}class ReadableStream{constructor(t={},r={}){if(t===undefined){t=null}else{assertObject(t,"First parameter")}const n=convertQueuingStrategy(r,"Second parameter");const a=convertUnderlyingDefaultOrByteSource(t,"First parameter");InitializeReadableStream(this);if(a.type==="bytes"){if(n.size!==undefined){throw new RangeError("The strategy for a byte stream cannot have a size function")}const t=ExtractHighWaterMark(n,0);SetUpReadableByteStreamControllerFromUnderlyingSource(this,a,t)}else{const t=ExtractSizeAlgorithm(n);const r=ExtractHighWaterMark(n,1);SetUpReadableStreamDefaultControllerFromUnderlyingSource(this,a,r,t)}}get locked(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("locked")}return IsReadableStreamLocked(this)}cancel(t=undefined){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("cancel"))}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"))}return ReadableStreamCancel(this,t)}getReader(t=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("getReader")}const r=convertReaderOptions(t,"First parameter");if(r.mode===undefined){return AcquireReadableStreamDefaultReader(this)}return AcquireReadableStreamBYOBReader(this)}pipeThrough(t,r={}){if(!IsReadableStream(this)){throw streamBrandCheckException$1("pipeThrough")}assertRequiredArgument(t,1,"pipeThrough");const n=convertReadableWritablePair(t,"First parameter");const a=convertPipeOptions(r,"Second parameter");if(IsReadableStreamLocked(this)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream")}if(IsWritableStreamLocked(n.writable)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream")}const o=ReadableStreamPipeTo(this,n.writable,a.preventClose,a.preventAbort,a.preventCancel,a.signal);setPromiseIsHandledToTrue(o);return n.readable}pipeTo(t,r={}){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("pipeTo"))}if(t===undefined){return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`)}if(!IsWritableStream(t)){return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`))}let n;try{n=convertPipeOptions(r,"Second parameter")}catch(t){return promiseRejectedWith(t)}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"))}if(IsWritableStreamLocked(t)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"))}return ReadableStreamPipeTo(this,t,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("tee")}const t=ReadableStreamTee(this);return CreateArrayFromList(t)}values(t=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("values")}const r=convertIteratorOptions(t,"First parameter");return AcquireReadableStreamAsyncIterator(this,r.preventCancel)}[_](t){return this.values(t)}static from(t){return ReadableStreamFrom(t)}}Object.defineProperties(ReadableStream,{from:{enumerable:true}});Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:true},getReader:{enumerable:true},pipeThrough:{enumerable:true},pipeTo:{enumerable:true},tee:{enumerable:true},values:{enumerable:true},locked:{enumerable:true}});setFunctionName(ReadableStream.from,"from");setFunctionName(ReadableStream.prototype.cancel,"cancel");setFunctionName(ReadableStream.prototype.getReader,"getReader");setFunctionName(ReadableStream.prototype.pipeThrough,"pipeThrough");setFunctionName(ReadableStream.prototype.pipeTo,"pipeTo");setFunctionName(ReadableStream.prototype.tee,"tee");setFunctionName(ReadableStream.prototype.values,"values");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ReadableStream.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:true})}Object.defineProperty(ReadableStream.prototype,_,{value:ReadableStream.prototype.values,writable:true,configurable:true});function CreateReadableStream(t,r,n,a=1,o=(()=>1)){const l=Object.create(ReadableStream.prototype);InitializeReadableStream(l);const i=Object.create(ReadableStreamDefaultController.prototype);SetUpReadableStreamDefaultController(l,i,t,r,n,a,o);return l}function CreateReadableByteStream(t,r,n){const a=Object.create(ReadableStream.prototype);InitializeReadableStream(a);const o=Object.create(ReadableByteStreamController.prototype);SetUpReadableByteStreamController(a,o,t,r,n,0,undefined);return a}function InitializeReadableStream(t){t._state="readable";t._reader=undefined;t._storedError=undefined;t._disturbed=false}function IsReadableStream(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_readableStreamController")){return false}return t instanceof ReadableStream}function IsReadableStreamLocked(t){if(t._reader===undefined){return false}return true}function ReadableStreamCancel(t,r){t._disturbed=true;if(t._state==="closed"){return promiseResolvedWith(undefined)}if(t._state==="errored"){return promiseRejectedWith(t._storedError)}ReadableStreamClose(t);const n=t._reader;if(n!==undefined&&IsReadableStreamBYOBReader(n)){const t=n._readIntoRequests;n._readIntoRequests=new SimpleQueue;t.forEach((t=>{t._closeSteps(undefined)}))}const a=t._readableStreamController[u](r);return transformPromiseWith(a,noop)}function ReadableStreamClose(t){t._state="closed";const r=t._reader;if(r===undefined){return}defaultReaderClosedPromiseResolve(r);if(IsReadableStreamDefaultReader(r)){const t=r._readRequests;r._readRequests=new SimpleQueue;t.forEach((t=>{t._closeSteps()}))}}function ReadableStreamError(t,r){t._state="errored";t._storedError=r;const n=t._reader;if(n===undefined){return}defaultReaderClosedPromiseReject(n,r);if(IsReadableStreamDefaultReader(n)){ReadableStreamDefaultReaderErrorReadRequests(n,r)}else{ReadableStreamBYOBReaderErrorReadIntoRequests(n,r)}}function streamBrandCheckException$1(t){return new TypeError(`ReadableStream.prototype.${t} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.highWaterMark;assertRequiredField(n,"highWaterMark","QueuingStrategyInit");return{highWaterMark:convertUnrestrictedDouble(n)}}const byteLengthSizeFunction=t=>t.byteLength;setFunctionName(byteLengthSizeFunction,"size");class ByteLengthQueuingStrategy{constructor(t){assertRequiredArgument(t,1,"ByteLengthQueuingStrategy");t=convertQueuingStrategyInit(t,"First parameter");this._byteLengthQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("highWaterMark")}return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("size")}return byteLengthSizeFunction}}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(ByteLengthQueuingStrategy.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:true})}function byteLengthBrandCheckException(t){return new TypeError(`ByteLengthQueuingStrategy.prototype.${t} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_byteLengthQueuingStrategyHighWaterMark")){return false}return t instanceof ByteLengthQueuingStrategy}const countSizeFunction=()=>1;setFunctionName(countSizeFunction,"size");class CountQueuingStrategy{constructor(t){assertRequiredArgument(t,1,"CountQueuingStrategy");t=convertQueuingStrategyInit(t,"First parameter");this._countQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("highWaterMark")}return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("size")}return countSizeFunction}}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(CountQueuingStrategy.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:true})}function countBrandCheckException(t){return new TypeError(`CountQueuingStrategy.prototype.${t} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_countQueuingStrategyHighWaterMark")){return false}return t instanceof CountQueuingStrategy}function convertTransformer(t,r){assertDictionary(t,r);const n=t===null||t===void 0?void 0:t.cancel;const a=t===null||t===void 0?void 0:t.flush;const o=t===null||t===void 0?void 0:t.readableType;const l=t===null||t===void 0?void 0:t.start;const i=t===null||t===void 0?void 0:t.transform;const s=t===null||t===void 0?void 0:t.writableType;return{cancel:n===undefined?undefined:convertTransformerCancelCallback(n,t,`${r} has member 'cancel' that`),flush:a===undefined?undefined:convertTransformerFlushCallback(a,t,`${r} has member 'flush' that`),readableType:o,start:l===undefined?undefined:convertTransformerStartCallback(l,t,`${r} has member 'start' that`),transform:i===undefined?undefined:convertTransformerTransformCallback(i,t,`${r} has member 'transform' that`),writableType:s}}function convertTransformerFlushCallback(t,r,n){assertFunction(t,n);return n=>promiseCall(t,r,[n])}function convertTransformerStartCallback(t,r,n){assertFunction(t,n);return n=>reflectCall(t,r,[n])}function convertTransformerTransformCallback(t,r,n){assertFunction(t,n);return(n,a)=>promiseCall(t,r,[n,a])}function convertTransformerCancelCallback(t,r,n){assertFunction(t,n);return n=>promiseCall(t,r,[n])}class TransformStream{constructor(t={},r={},n={}){if(t===undefined){t=null}const a=convertQueuingStrategy(r,"Second parameter");const o=convertQueuingStrategy(n,"Third parameter");const l=convertTransformer(t,"First parameter");if(l.readableType!==undefined){throw new RangeError("Invalid readableType specified")}if(l.writableType!==undefined){throw new RangeError("Invalid writableType specified")}const i=ExtractHighWaterMark(o,0);const s=ExtractSizeAlgorithm(o);const u=ExtractHighWaterMark(a,1);const d=ExtractSizeAlgorithm(a);let c;const m=newPromise((t=>{c=t}));InitializeTransformStream(this,m,u,d,i,s);SetUpTransformStreamDefaultControllerFromTransformer(this,l);if(l.start!==undefined){c(l.start(this._transformStreamController))}else{c(undefined)}}get readable(){if(!IsTransformStream(this)){throw streamBrandCheckException("readable")}return this._readable}get writable(){if(!IsTransformStream(this)){throw streamBrandCheckException("writable")}return this._writable}}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:true},writable:{enumerable:true}});if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(TransformStream.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:true})}function InitializeTransformStream(t,r,n,a,o,l){function startAlgorithm(){return r}function writeAlgorithm(r){return TransformStreamDefaultSinkWriteAlgorithm(t,r)}function abortAlgorithm(r){return TransformStreamDefaultSinkAbortAlgorithm(t,r)}function closeAlgorithm(){return TransformStreamDefaultSinkCloseAlgorithm(t)}t._writable=CreateWritableStream(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,n,a);function pullAlgorithm(){return TransformStreamDefaultSourcePullAlgorithm(t)}function cancelAlgorithm(r){return TransformStreamDefaultSourceCancelAlgorithm(t,r)}t._readable=CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,o,l);t._backpressure=undefined;t._backpressureChangePromise=undefined;t._backpressureChangePromise_resolve=undefined;TransformStreamSetBackpressure(t,true);t._transformStreamController=undefined}function IsTransformStream(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_transformStreamController")){return false}return t instanceof TransformStream}function TransformStreamError(t,r){ReadableStreamDefaultControllerError(t._readable._readableStreamController,r);TransformStreamErrorWritableAndUnblockWrite(t,r)}function TransformStreamErrorWritableAndUnblockWrite(t,r){TransformStreamDefaultControllerClearAlgorithms(t._transformStreamController);WritableStreamDefaultControllerErrorIfNeeded(t._writable._writableStreamController,r);TransformStreamUnblockWrite(t)}function TransformStreamUnblockWrite(t){if(t._backpressure){TransformStreamSetBackpressure(t,false)}}function TransformStreamSetBackpressure(t,r){if(t._backpressureChangePromise!==undefined){t._backpressureChangePromise_resolve()}t._backpressureChangePromise=newPromise((r=>{t._backpressureChangePromise_resolve=r}));t._backpressure=r}class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("desiredSize")}const t=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(t)}enqueue(t=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("enqueue")}TransformStreamDefaultControllerEnqueue(this,t)}error(t=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("error")}TransformStreamDefaultControllerError(this,t)}terminate(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("terminate")}TransformStreamDefaultControllerTerminate(this)}}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:true},error:{enumerable:true},terminate:{enumerable:true},desiredSize:{enumerable:true}});setFunctionName(TransformStreamDefaultController.prototype.enqueue,"enqueue");setFunctionName(TransformStreamDefaultController.prototype.error,"error");setFunctionName(TransformStreamDefaultController.prototype.terminate,"terminate");if(typeof Symbol.toStringTag==="symbol"){Object.defineProperty(TransformStreamDefaultController.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:true})}function IsTransformStreamDefaultController(t){if(!typeIsObject(t)){return false}if(!Object.prototype.hasOwnProperty.call(t,"_controlledTransformStream")){return false}return t instanceof TransformStreamDefaultController}function SetUpTransformStreamDefaultController(t,r,n,a,o){r._controlledTransformStream=t;t._transformStreamController=r;r._transformAlgorithm=n;r._flushAlgorithm=a;r._cancelAlgorithm=o;r._finishPromise=undefined;r._finishPromise_resolve=undefined;r._finishPromise_reject=undefined}function SetUpTransformStreamDefaultControllerFromTransformer(t,r){const n=Object.create(TransformStreamDefaultController.prototype);let a;let o;let l;if(r.transform!==undefined){a=t=>r.transform(t,n)}else{a=t=>{try{TransformStreamDefaultControllerEnqueue(n,t);return promiseResolvedWith(undefined)}catch(t){return promiseRejectedWith(t)}}}if(r.flush!==undefined){o=()=>r.flush(n)}else{o=()=>promiseResolvedWith(undefined)}if(r.cancel!==undefined){l=t=>r.cancel(t)}else{l=()=>promiseResolvedWith(undefined)}SetUpTransformStreamDefaultController(t,n,a,o,l)}function TransformStreamDefaultControllerClearAlgorithms(t){t._transformAlgorithm=undefined;t._flushAlgorithm=undefined;t._cancelAlgorithm=undefined}function TransformStreamDefaultControllerEnqueue(t,r){const n=t._controlledTransformStream;const a=n._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(a)){throw new TypeError("Readable side is not in a state that permits enqueue")}try{ReadableStreamDefaultControllerEnqueue(a,r)}catch(t){TransformStreamErrorWritableAndUnblockWrite(n,t);throw n._readable._storedError}const o=ReadableStreamDefaultControllerHasBackpressure(a);if(o!==n._backpressure){TransformStreamSetBackpressure(n,true)}}function TransformStreamDefaultControllerError(t,r){TransformStreamError(t._controlledTransformStream,r)}function TransformStreamDefaultControllerPerformTransform(t,r){const n=t._transformAlgorithm(r);return transformPromiseWith(n,undefined,(r=>{TransformStreamError(t._controlledTransformStream,r);throw r}))}function TransformStreamDefaultControllerTerminate(t){const r=t._controlledTransformStream;const n=r._readable._readableStreamController;ReadableStreamDefaultControllerClose(n);const a=new TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(r,a)}function TransformStreamDefaultSinkWriteAlgorithm(t,r){const n=t._transformStreamController;if(t._backpressure){const a=t._backpressureChangePromise;return transformPromiseWith(a,(()=>{const a=t._writable;const o=a._state;if(o==="erroring"){throw a._storedError}return TransformStreamDefaultControllerPerformTransform(n,r)}))}return TransformStreamDefaultControllerPerformTransform(n,r)}function TransformStreamDefaultSinkAbortAlgorithm(t,r){const n=t._transformStreamController;if(n._finishPromise!==undefined){return n._finishPromise}const a=t._readable;n._finishPromise=newPromise(((t,r)=>{n._finishPromise_resolve=t;n._finishPromise_reject=r}));const o=n._cancelAlgorithm(r);TransformStreamDefaultControllerClearAlgorithms(n);uponPromise(o,(()=>{if(a._state==="errored"){defaultControllerFinishPromiseReject(n,a._storedError)}else{ReadableStreamDefaultControllerError(a._readableStreamController,r);defaultControllerFinishPromiseResolve(n)}return null}),(t=>{ReadableStreamDefaultControllerError(a._readableStreamController,t);defaultControllerFinishPromiseReject(n,t);return null}));return n._finishPromise}function TransformStreamDefaultSinkCloseAlgorithm(t){const r=t._transformStreamController;if(r._finishPromise!==undefined){return r._finishPromise}const n=t._readable;r._finishPromise=newPromise(((t,n)=>{r._finishPromise_resolve=t;r._finishPromise_reject=n}));const a=r._flushAlgorithm();TransformStreamDefaultControllerClearAlgorithms(r);uponPromise(a,(()=>{if(n._state==="errored"){defaultControllerFinishPromiseReject(r,n._storedError)}else{ReadableStreamDefaultControllerClose(n._readableStreamController);defaultControllerFinishPromiseResolve(r)}return null}),(t=>{ReadableStreamDefaultControllerError(n._readableStreamController,t);defaultControllerFinishPromiseReject(r,t);return null}));return r._finishPromise}function TransformStreamDefaultSourcePullAlgorithm(t){TransformStreamSetBackpressure(t,false);return t._backpressureChangePromise}function TransformStreamDefaultSourceCancelAlgorithm(t,r){const n=t._transformStreamController;if(n._finishPromise!==undefined){return n._finishPromise}const a=t._writable;n._finishPromise=newPromise(((t,r)=>{n._finishPromise_resolve=t;n._finishPromise_reject=r}));const o=n._cancelAlgorithm(r);TransformStreamDefaultControllerClearAlgorithms(n);uponPromise(o,(()=>{if(a._state==="errored"){defaultControllerFinishPromiseReject(n,a._storedError)}else{WritableStreamDefaultControllerErrorIfNeeded(a._writableStreamController,r);TransformStreamUnblockWrite(t);defaultControllerFinishPromiseResolve(n)}return null}),(r=>{WritableStreamDefaultControllerErrorIfNeeded(a._writableStreamController,r);TransformStreamUnblockWrite(t);defaultControllerFinishPromiseReject(n,r);return null}));return n._finishPromise}function defaultControllerBrandCheckException(t){return new TypeError(`TransformStreamDefaultController.prototype.${t} can only be used on a TransformStreamDefaultController`)}function defaultControllerFinishPromiseResolve(t){if(t._finishPromise_resolve===undefined){return}t._finishPromise_resolve();t._finishPromise_resolve=undefined;t._finishPromise_reject=undefined}function defaultControllerFinishPromiseReject(t,r){if(t._finishPromise_reject===undefined){return}setPromiseIsHandledToTrue(t._finishPromise);t._finishPromise_reject(r);t._finishPromise_resolve=undefined;t._finishPromise_reject=undefined}function streamBrandCheckException(t){return new TypeError(`TransformStream.prototype.${t} can only be used on a TransformStream`)}t.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy;t.CountQueuingStrategy=CountQueuingStrategy;t.ReadableByteStreamController=ReadableByteStreamController;t.ReadableStream=ReadableStream;t.ReadableStreamBYOBReader=ReadableStreamBYOBReader;t.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest;t.ReadableStreamDefaultController=ReadableStreamDefaultController;t.ReadableStreamDefaultReader=ReadableStreamDefaultReader;t.TransformStream=TransformStream;t.TransformStreamDefaultController=TransformStreamDefaultController;t.WritableStream=WritableStream;t.WritableStreamDefaultController=WritableStreamDefaultController;t.WritableStreamDefaultWriter=WritableStreamDefaultWriter}))},81:function(t,r,n){"use strict";var a=this&&this.__awaiter||function(t,r,n,a){function adopt(t){return t instanceof n?t:new n((function(r){r(t)}))}return new(n||(n=Promise))((function(n,o){function fulfilled(t){try{step(a.next(t))}catch(t){o(t)}}function rejected(t){try{step(a["throw"](t))}catch(t){o(t)}}function step(t){t.done?n(t.value):adopt(t.value).then(fulfilled,rejected)}step((a=a.apply(t,r||[])).next())}))};Object.defineProperty(r,"__esModule",{value:true});r.trackBundleSize=trackBundleSize;const o=n(429);const l="https://github.com";const i=`${l}/assets`;const s=`${i}/manifest.json`;function getManifestFileData(){return a(this,void 0,void 0,(function*(){const t=yield(0,o.default)(s);if(t.ok){const r=yield t.json();return r}}))}function getChunkSize(t){return a(this,void 0,void 0,(function*(){const r=yield(0,o.default)(`https://github.com/assets/${t}`);if(r.ok){const t=yield r.text();const n=Buffer.byteLength(t);return n}}))}function fetchAndMeasureChunksForFile(t,r,n){return a(this,void 0,void 0,(function*(){const o=r["files"].map((t=>a(this,void 0,void 0,(function*(){return getChunkSize(t)})))).concat(getChunkSize(r["src"]));const l=yield Promise.all(o);const i=l.reduce(((t,r)=>t+r),0);n[t]=i}))}function trackBundleSize(t){return a(this,arguments,void 0,(function*({files:t}){const r=yield getManifestFileData();const n={};const o=t.map((t=>a(this,void 0,void 0,(function*(){const a=r[t];if(a){yield fetchAndMeasureChunksForFile(t,a,n)}else{console.error("Whoops! No file for ",t)}}))));yield Promise.all(o);console.log("cacheBundleSizes",n);return n}))}},300:t=>{"use strict";t.exports=require("buffer")},742:t=>{"use strict";t.exports=require("node:process")},477:t=>{"use strict";t.exports=require("node:stream/web")},267:t=>{"use strict";t.exports=require("worker_threads")},572:(t,r,n)=>{const a=65536;if(!globalThis.ReadableStream){try{const t=n(742);const{emitWarning:r}=t;try{t.emitWarning=()=>{};Object.assign(globalThis,n(477));t.emitWarning=r}catch(n){t.emitWarning=r;throw n}}catch(t){Object.assign(globalThis,n(452))}}try{const{Blob:t}=n(300);if(t&&!t.prototype.stream){t.prototype.stream=function name(t){let r=0;const n=this;return new ReadableStream({type:"bytes",async pull(t){const o=n.slice(r,Math.min(n.size,r+a));const l=await o.arrayBuffer();r+=l.byteLength;t.enqueue(new Uint8Array(l));if(r===n.size){t.close()}}})}}}catch(t){}},213:(t,r,n)=>{"use strict";n.d(r,{Z:()=>i});var a=n(410);const o=class File extends a.Z{#e=0;#t="";constructor(t,r,n={}){if(arguments.length<2){throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)}super(t,n);if(n===null)n={};const a=n.lastModified===undefined?Date.now():Number(n.lastModified);if(!Number.isNaN(a)){this.#e=a}this.#t=String(r)}get name(){return this.#t}get lastModified(){return this.#e}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](t){return!!t&&t instanceof a.Z&&/^(File)$/.test(t[Symbol.toStringTag])}};const l=o;const i=l},777:(t,r,n)=>{"use strict";n.d(r,{t6:()=>s.Z,$B:()=>i.Z,xB:()=>blobFrom,SX:()=>blobFromSync,e2:()=>fileFrom,RA:()=>fileFromSync});const a=require("node:fs");const o=require("node:path");var l=n(760);var i=n(213);var s=n(410);const{stat:u}=a.promises;const blobFromSync=(t,r)=>fromBlob((0,a.statSync)(t),t,r);const blobFrom=(t,r)=>u(t).then((n=>fromBlob(n,t,r)));const fileFrom=(t,r)=>u(t).then((n=>fromFile(n,t,r)));const fileFromSync=(t,r)=>fromFile((0,a.statSync)(t),t,r);const fromBlob=(t,r,n="")=>new s.Z([new BlobDataItem({path:r,size:t.size,lastModified:t.mtimeMs,start:0})],{type:n});const fromFile=(t,r,n="")=>new i.Z([new BlobDataItem({path:r,size:t.size,lastModified:t.mtimeMs,start:0})],(0,o.basename)(r),{type:n,lastModified:t.mtimeMs});class BlobDataItem{#r;#n;constructor(t){this.#r=t.path;this.#n=t.start;this.size=t.size;this.lastModified=t.lastModified}slice(t,r){return new BlobDataItem({path:this.#r,lastModified:this.lastModified,size:r-t,start:this.#n+t})}async*stream(){const{mtimeMs:t}=await u(this.#r);if(t>this.lastModified){throw new l("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError")}yield*(0,a.createReadStream)(this.#r,{start:this.#n,end:this.#n+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}const d=null&&blobFromSync},410:(t,r,n)=>{"use strict";n.d(r,{Z:()=>s});var a=n(572);
/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */const o=65536;async function*toIterator(t,r=true){for(const n of t){if("stream"in n){yield*n.stream()}else if(ArrayBuffer.isView(n)){if(r){let t=n.byteOffset;const r=n.byteOffset+n.byteLength;while(t!==r){const a=Math.min(r-t,o);const l=n.buffer.slice(t,t+a);t+=l.byteLength;yield new Uint8Array(l)}}else{yield n}}else{let t=0,r=n;while(t!==r.size){const n=r.slice(t,Math.min(r.size,t+o));const a=await n.arrayBuffer();t+=a.byteLength;yield new Uint8Array(a)}}}}const l=class Blob{#a=[];#o="";#l=0;#i="transparent";constructor(t=[],r={}){if(typeof t!=="object"||t===null){throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.")}if(typeof t[Symbol.iterator]!=="function"){throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.")}if(typeof r!=="object"&&typeof r!=="function"){throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.")}if(r===null)r={};const n=new TextEncoder;for(const r of t){let t;if(ArrayBuffer.isView(r)){t=new Uint8Array(r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength))}else if(r instanceof ArrayBuffer){t=new Uint8Array(r.slice(0))}else if(r instanceof Blob){t=r}else{t=n.encode(`${r}`)}this.#l+=ArrayBuffer.isView(t)?t.byteLength:t.size;this.#a.push(t)}this.#i=`${r.endings===undefined?"transparent":r.endings}`;const a=r.type===undefined?"":String(r.type);this.#o=/^[\x20-\x7E]*$/.test(a)?a:""}get size(){return this.#l}get type(){return this.#o}async text(){const t=new TextDecoder;let r="";for await(const n of toIterator(this.#a,false)){r+=t.decode(n,{stream:true})}r+=t.decode();return r}async arrayBuffer(){const t=new Uint8Array(this.size);let r=0;for await(const n of toIterator(this.#a,false)){t.set(n,r);r+=n.length}return t.buffer}stream(){const t=toIterator(this.#a,true);return new globalThis.ReadableStream({type:"bytes",async pull(r){const n=await t.next();n.done?r.close():r.enqueue(n.value)},async cancel(){await t.return()}})}slice(t=0,r=this.size,n=""){const{size:a}=this;let o=t<0?Math.max(a+t,0):Math.min(t,a);let l=r<0?Math.max(a+r,0):Math.min(r,a);const i=Math.max(l-o,0);const s=this.#a;const u=[];let d=0;for(const t of s){if(d>=i){break}const r=ArrayBuffer.isView(t)?t.byteLength:t.size;if(o&&r<=o){o-=r;l-=r}else{let n;if(ArrayBuffer.isView(t)){n=t.subarray(o,Math.min(r,l));d+=n.byteLength}else{n=t.slice(o,Math.min(r,l));d+=n.size}l-=r;u.push(n);o=0}}const c=new Blob([],{type:String(n).toLowerCase()});c.#l=i;c.#a=u;return c}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](t){return t&&typeof t==="object"&&typeof t.constructor==="function"&&(typeof t.stream==="function"||typeof t.arrayBuffer==="function")&&/^(Blob|File)$/.test(t[Symbol.toStringTag])}};Object.defineProperties(l.prototype,{size:{enumerable:true},type:{enumerable:true},slice:{enumerable:true}});const i=l;const s=i},10:(t,r,n)=>{"use strict";n.d(r,{Ct:()=>m,au:()=>formDataToBlob});var a=n(410);var o=n(213);
/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */var{toStringTag:l,iterator:i,hasInstance:s}=Symbol,u=Math.random,d="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),f=(t,r,n)=>(t+="",/^(Blob|File)$/.test(r&&r[l])?[(n=n!==void 0?n+"":r[l]=="File"?r.name:"blob",t),r.name!==n||r[l]=="blob"?new o.Z([r],n,r):r]:[t,r+""]),e=(t,r)=>(r?t:t.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),x=(t,r,n)=>{if(r.length<n){throw new TypeError(`Failed to execute '${t}' on 'FormData': ${n} arguments required, but only ${r.length} present.`)}};const c=null&&F;const m=class FormData{#s=[];constructor(...t){if(t.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}get[l](){return"FormData"}[i](){return this.entries()}static[s](t){return t&&typeof t==="object"&&t[l]==="FormData"&&!d.some((r=>typeof t[r]!="function"))}append(...t){x("append",arguments,2);this.#s.push(f(...t))}delete(t){x("delete",arguments,1);t+="";this.#s=this.#s.filter((([r])=>r!==t))}get(t){x("get",arguments,1);t+="";for(var r=this.#s,n=r.length,a=0;a<n;a++)if(r[a][0]===t)return r[a][1];return null}getAll(t,r){x("getAll",arguments,1);r=[];t+="";this.#s.forEach((n=>n[0]===t&&r.push(n[1])));return r}has(t){x("has",arguments,1);t+="";return this.#s.some((r=>r[0]===t))}forEach(t,r){x("forEach",arguments,1);for(var[n,a]of this)t.call(r,a,n,this)}set(...t){x("set",arguments,2);var r=[],n=!0;t=f(...t);this.#s.forEach((a=>{a[0]===t[0]?n&&(n=!r.push(t)):r.push(a)}));n&&r.push(t);this.#s=r}*entries(){yield*this.#s}*keys(){for(var[t]of this)yield t}*values(){for(var[,t]of this)yield t}};function formDataToBlob(t,r=a.Z){var n=`${u()}${u()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),o=[],l=`--${n}\r\nContent-Disposition: form-data; name="`;t.forEach(((t,r)=>typeof t=="string"?o.push(l+e(r)+`"\r\n\r\n${t.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r\n`):o.push(l+e(r)+`"; filename="${e(t.name,1)}"\r\nContent-Type: ${t.type||"application/octet-stream"}\r\n\r\n`,t,"\r\n")));o.push(`--${n}--`);return new r(o,{type:"multipart/form-data; boundary="+n})}},429:(t,r,n)=>{"use strict";n.r(r);n.d(r,{AbortError:()=>AbortError,Blob:()=>E.t6,FetchError:()=>FetchError,File:()=>E.$B,FormData:()=>m.Ct,Headers:()=>Headers,Request:()=>Request,Response:()=>Response,blobFrom:()=>E.xB,blobFromSync:()=>E.SX,default:()=>fetch,fileFrom:()=>E.e2,fileFromSync:()=>E.RA,isRedirect:()=>isRedirect});const a=require("node:http");const o=require("node:https");const l=require("node:zlib");const i=require("node:stream");const s=require("node:buffer");function dataUriToBuffer(t){if(!/^data:/i.test(t)){throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")')}t=t.replace(/\r?\n/g,"");const r=t.indexOf(",");if(r===-1||r<=4){throw new TypeError("malformed data: URI")}const n=t.substring(5,r).split(";");let a="";let o=false;const l=n[0]||"text/plain";let i=l;for(let t=1;t<n.length;t++){if(n[t]==="base64"){o=true}else if(n[t]){i+=`;${n[t]}`;if(n[t].indexOf("charset=")===0){a=n[t].substring(8)}}}if(!n[0]&&!a.length){i+=";charset=US-ASCII";a="US-ASCII"}const s=o?"base64":"ascii";const u=unescape(t.substring(r+1));const d=Buffer.from(u,s);d.type=l;d.typeFull=i;d.charset=a;return d}const u=dataUriToBuffer;const d=require("node:util");var c=n(410);var m=n(10);class FetchBaseError extends Error{constructor(t,r){super(t);Error.captureStackTrace(this,this.constructor);this.type=r}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class FetchError extends FetchBaseError{constructor(t,r,n){super(t,r);if(n){this.code=this.errno=n.code;this.erroredSysCall=n.syscall}}}const b=Symbol.toStringTag;const isURLSearchParameters=t=>typeof t==="object"&&typeof t.append==="function"&&typeof t.delete==="function"&&typeof t.get==="function"&&typeof t.getAll==="function"&&typeof t.has==="function"&&typeof t.set==="function"&&typeof t.sort==="function"&&t[b]==="URLSearchParams";const isBlob=t=>t&&typeof t==="object"&&typeof t.arrayBuffer==="function"&&typeof t.type==="string"&&typeof t.stream==="function"&&typeof t.constructor==="function"&&/^(Blob|File)$/.test(t[b]);const isAbortSignal=t=>typeof t==="object"&&(t[b]==="AbortSignal"||t[b]==="EventTarget");const isDomainOrSubdomain=(t,r)=>{const n=new URL(r).hostname;const a=new URL(t).hostname;return n===a||n.endsWith(`.${a}`)};const isSameProtocol=(t,r)=>{const n=new URL(r).protocol;const a=new URL(t).protocol;return n===a};const h=(0,d.promisify)(i.pipeline);const p=Symbol("Body internals");class Body{constructor(t,{size:r=0}={}){let n=null;if(t===null){t=null}else if(isURLSearchParameters(t)){t=s.Buffer.from(t.toString())}else if(isBlob(t)){}else if(s.Buffer.isBuffer(t)){}else if(d.types.isAnyArrayBuffer(t)){t=s.Buffer.from(t)}else if(ArrayBuffer.isView(t)){t=s.Buffer.from(t.buffer,t.byteOffset,t.byteLength)}else if(t instanceof i){}else if(t instanceof m.Ct){t=(0,m.au)(t);n=t.type.split("=")[1]}else{t=s.Buffer.from(String(t))}let a=t;if(s.Buffer.isBuffer(t)){a=i.Readable.from(t)}else if(isBlob(t)){a=i.Readable.from(t.stream())}this[p]={body:t,stream:a,boundary:n,disturbed:false,error:null};this.size=r;if(t instanceof i){t.on("error",(t=>{const r=t instanceof FetchBaseError?t:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${t.message}`,"system",t);this[p].error=r}))}}get body(){return this[p].stream}get bodyUsed(){return this[p].disturbed}async arrayBuffer(){const{buffer:t,byteOffset:r,byteLength:n}=await consumeBody(this);return t.slice(r,r+n)}async formData(){const t=this.headers.get("content-type");if(t.startsWith("application/x-www-form-urlencoded")){const t=new m.Ct;const r=new URLSearchParams(await this.text());for(const[n,a]of r){t.append(n,a)}return t}const{toFormData:r}=await n.e(37).then(n.bind(n,37));return r(this.body,t)}async blob(){const t=this.headers&&this.headers.get("content-type")||this[p].body&&this[p].body.type||"";const r=await this.arrayBuffer();return new c.Z([r],{type:t})}async json(){const t=await this.text();return JSON.parse(t)}async text(){const t=await consumeBody(this);return(new TextDecoder).decode(t)}buffer(){return consumeBody(this)}}Body.prototype.buffer=(0,d.deprecate)(Body.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer");Object.defineProperties(Body.prototype,{body:{enumerable:true},bodyUsed:{enumerable:true},arrayBuffer:{enumerable:true},blob:{enumerable:true},json:{enumerable:true},text:{enumerable:true},data:{get:(0,d.deprecate)((()=>{}),"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});async function consumeBody(t){if(t[p].disturbed){throw new TypeError(`body used already for: ${t.url}`)}t[p].disturbed=true;if(t[p].error){throw t[p].error}const{body:r}=t;if(r===null){return s.Buffer.alloc(0)}if(!(r instanceof i)){return s.Buffer.alloc(0)}const n=[];let a=0;try{for await(const o of r){if(t.size>0&&a+o.length>t.size){const n=new FetchError(`content size at ${t.url} over limit: ${t.size}`,"max-size");r.destroy(n);throw n}a+=o.length;n.push(o)}}catch(r){const n=r instanceof FetchBaseError?r:new FetchError(`Invalid response body while trying to fetch ${t.url}: ${r.message}`,"system",r);throw n}if(r.readableEnded===true||r._readableState.ended===true){try{if(n.every((t=>typeof t==="string"))){return s.Buffer.from(n.join(""))}return s.Buffer.concat(n,a)}catch(r){throw new FetchError(`Could not create Buffer from response body for ${t.url}: ${r.message}`,"system",r)}}else{throw new FetchError(`Premature close of server response while trying to fetch ${t.url}`)}}const clone=(t,r)=>{let n;let a;let{body:o}=t[p];if(t.bodyUsed){throw new Error("cannot clone body after it is used")}if(o instanceof i&&typeof o.getBoundary!=="function"){n=new i.PassThrough({highWaterMark:r});a=new i.PassThrough({highWaterMark:r});o.pipe(n);o.pipe(a);t[p].stream=n;o=a}return o};const S=(0,d.deprecate)((t=>t.getBoundary()),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167");const extractContentType=(t,r)=>{if(t===null){return null}if(typeof t==="string"){return"text/plain;charset=UTF-8"}if(isURLSearchParameters(t)){return"application/x-www-form-urlencoded;charset=UTF-8"}if(isBlob(t)){return t.type||null}if(s.Buffer.isBuffer(t)||d.types.isAnyArrayBuffer(t)||ArrayBuffer.isView(t)){return null}if(t instanceof m.Ct){return`multipart/form-data; boundary=${r[p].boundary}`}if(t&&typeof t.getBoundary==="function"){return`multipart/form-data;boundary=${S(t)}`}if(t instanceof i){return null}return"text/plain;charset=UTF-8"};const getTotalBytes=t=>{const{body:r}=t[p];if(r===null){return 0}if(isBlob(r)){return r.size}if(s.Buffer.isBuffer(r)){return r.length}if(r&&typeof r.getLengthSync==="function"){return r.hasKnownLength&&r.hasKnownLength()?r.getLengthSync():null}return null};const writeToStream=async(t,{body:r})=>{if(r===null){t.end()}else{await h(r,t)}};const y=typeof a.validateHeaderName==="function"?a.validateHeaderName:t=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(t)){const r=new TypeError(`Header name must be a valid HTTP token [${t}]`);Object.defineProperty(r,"code",{value:"ERR_INVALID_HTTP_TOKEN"});throw r}};const R=typeof a.validateHeaderValue==="function"?a.validateHeaderValue:(t,r)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(r)){const r=new TypeError(`Invalid character in header content ["${t}"]`);Object.defineProperty(r,"code",{value:"ERR_INVALID_CHAR"});throw r}};class Headers extends URLSearchParams{constructor(t){let r=[];if(t instanceof Headers){const n=t.raw();for(const[t,a]of Object.entries(n)){r.push(...a.map((r=>[t,r])))}}else if(t==null){}else if(typeof t==="object"&&!d.types.isBoxedPrimitive(t)){const n=t[Symbol.iterator];if(n==null){r.push(...Object.entries(t))}else{if(typeof n!=="function"){throw new TypeError("Header pairs must be iterable")}r=[...t].map((t=>{if(typeof t!=="object"||d.types.isBoxedPrimitive(t)){throw new TypeError("Each header pair must be an iterable object")}return[...t]})).map((t=>{if(t.length!==2){throw new TypeError("Each header pair must be a name/value tuple")}return[...t]}))}}else{throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)")}r=r.length>0?r.map((([t,r])=>{y(t);R(t,String(r));return[String(t).toLowerCase(),String(r)]})):undefined;super(r);return new Proxy(this,{get(t,r,n){switch(r){case"append":case"set":return(n,a)=>{y(n);R(n,String(a));return URLSearchParams.prototype[r].call(t,String(n).toLowerCase(),String(a))};case"delete":case"has":case"getAll":return n=>{y(n);return URLSearchParams.prototype[r].call(t,String(n).toLowerCase())};case"keys":return()=>{t.sort();return new Set(URLSearchParams.prototype.keys.call(t)).keys()};default:return Reflect.get(t,r,n)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(t){const r=this.getAll(t);if(r.length===0){return null}let n=r.join(", ");if(/^content-encoding$/i.test(t)){n=n.toLowerCase()}return n}forEach(t,r=undefined){for(const n of this.keys()){Reflect.apply(t,r,[this.get(n),n,this])}}*values(){for(const t of this.keys()){yield this.get(t)}}*entries(){for(const t of this.keys()){yield[t,this.get(t)]}}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce(((t,r)=>{t[r]=this.getAll(r);return t}),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce(((t,r)=>{const n=this.getAll(r);if(r==="host"){t[r]=n[0]}else{t[r]=n.length>1?n:n[0]}return t}),{})}}Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce(((t,r)=>{t[r]={enumerable:true};return t}),{}));function fromRawHeaders(t=[]){return new Headers(t.reduce(((t,r,n,a)=>{if(n%2===0){t.push(a.slice(n,n+2))}return t}),[]).filter((([t,r])=>{try{y(t);R(t,String(r));return true}catch{return false}})))}const g=new Set([301,302,303,307,308]);const isRedirect=t=>g.has(t);const _=Symbol("Response internals");class Response extends Body{constructor(t=null,r={}){super(t,r);const n=r.status!=null?r.status:200;const a=new Headers(r.headers);if(t!==null&&!a.has("Content-Type")){const r=extractContentType(t,this);if(r){a.append("Content-Type",r)}}this[_]={type:"default",url:r.url,status:n,statusText:r.statusText||"",headers:a,counter:r.counter,highWaterMark:r.highWaterMark}}get type(){return this[_].type}get url(){return this[_].url||""}get status(){return this[_].status}get ok(){return this[_].status>=200&&this[_].status<300}get redirected(){return this[_].counter>0}get statusText(){return this[_].statusText}get headers(){return this[_].headers}get highWaterMark(){return this[_].highWaterMark}clone(){return new Response(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(t,r=302){if(!isRedirect(r)){throw new RangeError('Failed to execute "redirect" on "response": Invalid status code')}return new Response(null,{headers:{location:new URL(t).toString()},status:r})}static error(){const t=new Response(null,{status:0,statusText:""});t[_].type="error";return t}static json(t=undefined,r={}){const n=JSON.stringify(t);if(n===undefined){throw new TypeError("data is not JSON serializable")}const a=new Headers(r&&r.headers);if(!a.has("content-type")){a.set("content-type","application/json")}return new Response(n,{...r,headers:a})}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(Response.prototype,{type:{enumerable:true},url:{enumerable:true},status:{enumerable:true},ok:{enumerable:true},redirected:{enumerable:true},statusText:{enumerable:true},headers:{enumerable:true},clone:{enumerable:true}});const C=require("node:url");const getSearch=t=>{if(t.search){return t.search}const r=t.href.length-1;const n=t.hash||(t.href[r]==="#"?"#":"");return t.href[r-n.length]==="?"?"?":""};const w=require("node:net");function stripURLForUseAsAReferrer(t,r=false){if(t==null){return"no-referrer"}t=new URL(t);if(/^(about|blob|data):$/.test(t.protocol)){return"no-referrer"}t.username="";t.password="";t.hash="";if(r){t.pathname="";t.search=""}return t}const W=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]);const B="strict-origin-when-cross-origin";function validateReferrerPolicy(t){if(!W.has(t)){throw new TypeError(`Invalid referrerPolicy: ${t}`)}return t}function isOriginPotentiallyTrustworthy(t){if(/^(http|ws)s:$/.test(t.protocol)){return true}const r=t.host.replace(/(^\[)|(]$)/g,"");const n=(0,w.isIP)(r);if(n===4&&/^127\./.test(r)){return true}if(n===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(r)){return true}if(t.host==="localhost"||t.host.endsWith(".localhost")){return false}if(t.protocol==="file:"){return true}return false}function isUrlPotentiallyTrustworthy(t){if(/^about:(blank|srcdoc)$/.test(t)){return true}if(t.protocol==="data:"){return true}if(/^(blob|filesystem):$/.test(t.protocol)){return true}return isOriginPotentiallyTrustworthy(t)}function determineRequestsReferrer(t,{referrerURLCallback:r,referrerOriginCallback:n}={}){if(t.referrer==="no-referrer"||t.referrerPolicy===""){return null}const a=t.referrerPolicy;if(t.referrer==="about:client"){return"no-referrer"}const o=t.referrer;let l=stripURLForUseAsAReferrer(o);let i=stripURLForUseAsAReferrer(o,true);if(l.toString().length>4096){l=i}if(r){l=r(l)}if(n){i=n(i)}const s=new URL(t.url);switch(a){case"no-referrer":return"no-referrer";case"origin":return i;case"unsafe-url":return l;case"strict-origin":if(isUrlPotentiallyTrustworthy(l)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return i.toString();case"strict-origin-when-cross-origin":if(l.origin===s.origin){return l}if(isUrlPotentiallyTrustworthy(l)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return i;case"same-origin":if(l.origin===s.origin){return l}return"no-referrer";case"origin-when-cross-origin":if(l.origin===s.origin){return l}return i;case"no-referrer-when-downgrade":if(isUrlPotentiallyTrustworthy(l)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return l;default:throw new TypeError(`Invalid referrerPolicy: ${a}`)}}function parseReferrerPolicyFromHeader(t){const r=(t.get("referrer-policy")||"").split(/[,\s]+/);let n="";for(const t of r){if(t&&W.has(t)){n=t}}return n}const P=Symbol("Request internals");const isRequest=t=>typeof t==="object"&&typeof t[P]==="object";const T=(0,d.deprecate)((()=>{}),".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class Request extends Body{constructor(t,r={}){let n;if(isRequest(t)){n=new URL(t.url)}else{n=new URL(t);t={}}if(n.username!==""||n.password!==""){throw new TypeError(`${n} is an url with embedded credentials.`)}let a=r.method||t.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(a)){a=a.toUpperCase()}if(!isRequest(r)&&"data"in r){T()}if((r.body!=null||isRequest(t)&&t.body!==null)&&(a==="GET"||a==="HEAD")){throw new TypeError("Request with GET/HEAD method cannot have body")}const o=r.body?r.body:isRequest(t)&&t.body!==null?clone(t):null;super(o,{size:r.size||t.size||0});const l=new Headers(r.headers||t.headers||{});if(o!==null&&!l.has("Content-Type")){const t=extractContentType(o,this);if(t){l.set("Content-Type",t)}}let i=isRequest(t)?t.signal:null;if("signal"in r){i=r.signal}if(i!=null&&!isAbortSignal(i)){throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget")}let s=r.referrer==null?t.referrer:r.referrer;if(s===""){s="no-referrer"}else if(s){const t=new URL(s);s=/^about:(\/\/)?client$/.test(t)?"client":t}else{s=undefined}this[P]={method:a,redirect:r.redirect||t.redirect||"follow",headers:l,parsedURL:n,signal:i,referrer:s};this.follow=r.follow===undefined?t.follow===undefined?20:t.follow:r.follow;this.compress=r.compress===undefined?t.compress===undefined?true:t.compress:r.compress;this.counter=r.counter||t.counter||0;this.agent=r.agent||t.agent;this.highWaterMark=r.highWaterMark||t.highWaterMark||16384;this.insecureHTTPParser=r.insecureHTTPParser||t.insecureHTTPParser||false;this.referrerPolicy=r.referrerPolicy||t.referrerPolicy||""}get method(){return this[P].method}get url(){return(0,C.format)(this[P].parsedURL)}get headers(){return this[P].headers}get redirect(){return this[P].redirect}get signal(){return this[P].signal}get referrer(){if(this[P].referrer==="no-referrer"){return""}if(this[P].referrer==="client"){return"about:client"}if(this[P].referrer){return this[P].referrer.toString()}return undefined}get referrerPolicy(){return this[P].referrerPolicy}set referrerPolicy(t){this[P].referrerPolicy=validateReferrerPolicy(t)}clone(){return new Request(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties(Request.prototype,{method:{enumerable:true},url:{enumerable:true},headers:{enumerable:true},redirect:{enumerable:true},clone:{enumerable:true},signal:{enumerable:true},referrer:{enumerable:true},referrerPolicy:{enumerable:true}});const getNodeRequestOptions=t=>{const{parsedURL:r}=t[P];const n=new Headers(t[P].headers);if(!n.has("Accept")){n.set("Accept","*/*")}let a=null;if(t.body===null&&/^(post|put)$/i.test(t.method)){a="0"}if(t.body!==null){const r=getTotalBytes(t);if(typeof r==="number"&&!Number.isNaN(r)){a=String(r)}}if(a){n.set("Content-Length",a)}if(t.referrerPolicy===""){t.referrerPolicy=B}if(t.referrer&&t.referrer!=="no-referrer"){t[P].referrer=determineRequestsReferrer(t)}else{t[P].referrer="no-referrer"}if(t[P].referrer instanceof URL){n.set("Referer",t.referrer)}if(!n.has("User-Agent")){n.set("User-Agent","node-fetch")}if(t.compress&&!n.has("Accept-Encoding")){n.set("Accept-Encoding","gzip, deflate, br")}let{agent:o}=t;if(typeof o==="function"){o=o(r)}const l=getSearch(r);const i={path:r.pathname+l,method:t.method,headers:n[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:t.insecureHTTPParser,agent:o};return{parsedURL:r,options:i}};class AbortError extends FetchBaseError{constructor(t,r="aborted"){super(t,r)}}var E=n(777);const v=new Set(["data:","http:","https:"]);async function fetch(t,r){return new Promise(((n,s)=>{const d=new Request(t,r);const{parsedURL:c,options:m}=getNodeRequestOptions(d);if(!v.has(c.protocol)){throw new TypeError(`node-fetch cannot load ${t}. URL scheme "${c.protocol.replace(/:$/,"")}" is not supported.`)}if(c.protocol==="data:"){const t=u(d.url);const r=new Response(t,{headers:{"Content-Type":t.typeFull}});n(r);return}const b=(c.protocol==="https:"?o:a).request;const{signal:h}=d;let p=null;const abort=()=>{const t=new AbortError("The operation was aborted.");s(t);if(d.body&&d.body instanceof i.Readable){d.body.destroy(t)}if(!p||!p.body){return}p.body.emit("error",t)};if(h&&h.aborted){abort();return}const abortAndFinalize=()=>{abort();finalize()};const S=b(c.toString(),m);if(h){h.addEventListener("abort",abortAndFinalize)}const finalize=()=>{S.abort();if(h){h.removeEventListener("abort",abortAndFinalize)}};S.on("error",(t=>{s(new FetchError(`request to ${d.url} failed, reason: ${t.message}`,"system",t));finalize()}));fixResponseChunkedTransferBadEnding(S,(t=>{if(p&&p.body){p.body.destroy(t)}}));if(process.version<"v14"){S.on("socket",(t=>{let r;t.prependListener("end",(()=>{r=t._eventsCount}));t.prependListener("close",(n=>{if(p&&r<t._eventsCount&&!n){const t=new Error("Premature close");t.code="ERR_STREAM_PREMATURE_CLOSE";p.body.emit("error",t)}}))}))}S.on("response",(t=>{S.setTimeout(0);const a=fromRawHeaders(t.rawHeaders);if(isRedirect(t.statusCode)){const o=a.get("Location");let l=null;try{l=o===null?null:new URL(o,d.url)}catch{if(d.redirect!=="manual"){s(new FetchError(`uri requested responds with an invalid redirect URL: ${o}`,"invalid-redirect"));finalize();return}}switch(d.redirect){case"error":s(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${d.url}`,"no-redirect"));finalize();return;case"manual":break;case"follow":{if(l===null){break}if(d.counter>=d.follow){s(new FetchError(`maximum redirect reached at: ${d.url}`,"max-redirect"));finalize();return}const o={headers:new Headers(d.headers),follow:d.follow,counter:d.counter+1,agent:d.agent,compress:d.compress,method:d.method,body:clone(d),signal:d.signal,size:d.size,referrer:d.referrer,referrerPolicy:d.referrerPolicy};if(!isDomainOrSubdomain(d.url,l)||!isSameProtocol(d.url,l)){for(const t of["authorization","www-authenticate","cookie","cookie2"]){o.headers.delete(t)}}if(t.statusCode!==303&&d.body&&r.body instanceof i.Readable){s(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect"));finalize();return}if(t.statusCode===303||(t.statusCode===301||t.statusCode===302)&&d.method==="POST"){o.method="GET";o.body=undefined;o.headers.delete("content-length")}const u=parseReferrerPolicyFromHeader(a);if(u){o.referrerPolicy=u}n(fetch(new Request(l,o)));finalize();return}default:return s(new TypeError(`Redirect option '${d.redirect}' is not a valid value of RequestRedirect`))}}if(h){t.once("end",(()=>{h.removeEventListener("abort",abortAndFinalize)}))}let o=(0,i.pipeline)(t,new i.PassThrough,(t=>{if(t){s(t)}}));if(process.version<"v12.10"){t.on("aborted",abortAndFinalize)}const u={url:d.url,status:t.statusCode,statusText:t.statusMessage,headers:a,size:d.size,counter:d.counter,highWaterMark:d.highWaterMark};const c=a.get("Content-Encoding");if(!d.compress||d.method==="HEAD"||c===null||t.statusCode===204||t.statusCode===304){p=new Response(o,u);n(p);return}const m={flush:l.Z_SYNC_FLUSH,finishFlush:l.Z_SYNC_FLUSH};if(c==="gzip"||c==="x-gzip"){o=(0,i.pipeline)(o,l.createGunzip(m),(t=>{if(t){s(t)}}));p=new Response(o,u);n(p);return}if(c==="deflate"||c==="x-deflate"){const r=(0,i.pipeline)(t,new i.PassThrough,(t=>{if(t){s(t)}}));r.once("data",(t=>{if((t[0]&15)===8){o=(0,i.pipeline)(o,l.createInflate(),(t=>{if(t){s(t)}}))}else{o=(0,i.pipeline)(o,l.createInflateRaw(),(t=>{if(t){s(t)}}))}p=new Response(o,u);n(p)}));r.once("end",(()=>{if(!p){p=new Response(o,u);n(p)}}));return}if(c==="br"){o=(0,i.pipeline)(o,l.createBrotliDecompress(),(t=>{if(t){s(t)}}));p=new Response(o,u);n(p);return}p=new Response(o,u);n(p)}));writeToStream(S,d).catch(s)}))}function fixResponseChunkedTransferBadEnding(t,r){const n=s.Buffer.from("0\r\n\r\n");let a=false;let o=false;let l;t.on("response",(t=>{const{headers:r}=t;a=r["transfer-encoding"]==="chunked"&&!r["content-length"]}));t.on("socket",(i=>{const onSocketClose=()=>{if(a&&!o){const t=new Error("Premature close");t.code="ERR_STREAM_PREMATURE_CLOSE";r(t)}};const onData=t=>{o=s.Buffer.compare(t.slice(-5),n)===0;if(!o&&l){o=s.Buffer.compare(l.slice(-3),n.slice(0,3))===0&&s.Buffer.compare(t.slice(-2),n.slice(3))===0}l=t};i.prependListener("close",onSocketClose);i.on("data",onData);t.on("close",(()=>{i.removeListener("close",onSocketClose);i.removeListener("data",onData)}))}))}}};var r={};function __nccwpck_require__(n){var a=r[n];if(a!==undefined){return a.exports}var o=r[n]={exports:{}};var l=true;try{t[n].call(o.exports,o,o.exports,__nccwpck_require__);l=false}finally{if(l)delete r[n]}return o.exports}__nccwpck_require__.m=t;(()=>{__nccwpck_require__.d=(t,r)=>{for(var n in r){if(__nccwpck_require__.o(r,n)&&!__nccwpck_require__.o(t,n)){Object.defineProperty(t,n,{enumerable:true,get:r[n]})}}}})();(()=>{__nccwpck_require__.f={};__nccwpck_require__.e=t=>Promise.all(Object.keys(__nccwpck_require__.f).reduce(((r,n)=>{__nccwpck_require__.f[n](t,r);return r}),[]))})();(()=>{__nccwpck_require__.u=t=>""+t+".index.js"})();(()=>{__nccwpck_require__.o=(t,r)=>Object.prototype.hasOwnProperty.call(t,r)})();(()=>{__nccwpck_require__.r=t=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(t,"__esModule",{value:true})}})();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";(()=>{var t={179:1};var installChunk=r=>{var n=r.modules,a=r.ids,o=r.runtime;for(var l in n){if(__nccwpck_require__.o(n,l)){__nccwpck_require__.m[l]=n[l]}}if(o)o(__nccwpck_require__);for(var i=0;i<a.length;i++)t[a[i]]=1};__nccwpck_require__.f.require=(r,n)=>{if(!t[r]){if(true){installChunk(require("./"+__nccwpck_require__.u(r)))}else t[r]=1}}})();var n={};(()=>{"use strict";var t=n;Object.defineProperty(t,"__esModule",{value:true});const r=__nccwpck_require__(81);(0,r.trackBundleSize)({files:["mergebox-partial.js","pull-request-viewer.js","pull-request-commits.js","pulls-dashboard.js"]})})();module.exports=n})();
//# sourceMappingURL=index.js.map